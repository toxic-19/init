/*
 Navicat Premium Data Transfer

 Source Server         : blog_db
 Source Server Type    : MySQL
 Source Server Version : 80028
 Source Host           : localhost:3306
 Source Schema         : order

 Target Server Type    : MySQL
 Target Server Version : 80028
 File Encoding         : 65001

 Date: 10/05/2024 15:01:17
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for articles
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '文章id\r\n',
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '文章标题',
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '内容简介',
  `publishedTime` datetime(0) NULL DEFAULT NULL COMMENT '发布时间 | 修改时间',
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '文章内容',
  `author` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '作者',
  `preview` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '文章预览内容',
  `createdAt` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0),
  `updatedAt` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0),
  `isDel` int(0) NULL DEFAULT 1 COMMENT '删除 0 为删除 1为未删除',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 64 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of articles
-- ----------------------------
INSERT INTO `articles` VALUES (1, '修改第一篇文章title', '商业授权及价格', '2024-03-12 19:51:52', '# 授权说明\r\n **我们的软件都是按 ==私有化部署== 的方式授权，而不是SaaS服务，数据完全私有存储，更安全放心！**\r\n \r\n为了项目健康可持续发展、保持稳定的更新及系统安全性，我们选择了增加一个商业支持的版本，我们一直在朝着更好用、更现代化的方向努力着。\r\n\r\n如果项目符合您的审美，可以直接下载部署使用，如果软件功能符合您的预期，也欢迎购买授权来支持我们。\r\n\r\n# 版本及价格\r\n以下均为商业版本的授权，商业版也可直接下载部署并使用，开源版源码开放，无需任何授权即可使用。\r\n\r\n|功能|基础版|个人版|团队版|企业版<Badge type=\"tip\" text=\"推荐\" vertical=\"top\"/>|旗舰版|\r\n|-|-|-|-|-|-|\r\n|价格|免费|~~￥100~~ ^限免^|￥500|￥3,000|￥10,000|\r\n|帐号个数|1个|1个|5个|不限帐号|不限帐号|\r\n|开放空间|1个|不限|不限|不限|不限|\r\n|单页分享|1个|不限|不限|不限|不限|\r\n|版权声明|有|有|无|无|无|\r\n|新版更新权|-|6个月|6个月|1年|10年|\r\n|老用户续费|-|-|六折|六折|-|\r\n\r\n我们在提供了非常完备的功能的同时也制定了非常优惠的价格，且我们实行的是买断制，**即购买后可永久使用**，仅新版本的更新具有一定的时限，超过该时限之后如果新版本有功能是您想更新部署使用的，则需要再次购买授权。\r\n\r\n> - 老用户续费可享受现价**六折**优惠\r\n> - 商业版使用本地私有化部署，**均不提供源代码**\r\n> - 以上均为含税的价格，均可开具**电子发票**和签署合同\r\n> - 团队版可在5个帐号的基础上按**￥100一个帐号**的价格自由增加\r\n> - 个人版申请免费授权不会强制您做任何事情，只需提供访问的**域名或IP**即可\r\n> - 每份授权只包含一个域名的授权，一级域名不变的情况下最多支持修改3次二级域名\r\n> - 我们会随着功能的增加不定期调整价格策略，如果软件符合需求请尽早与我们沟通哦\r\n\r\n## 各版本如何选择\r\n- 如果您是企业用户，我们推荐您选择企业版，没有帐号个数限制，同时也具有更长的新版更新权。\r\n- 如果您是初创团队，您可以选择按用户个数授权的团队版，满足当前人数暂且不是很多的需求场景。\r\n- 如果您是开源用户，我们提供有免费的授权优惠策略，满足条件可免费申请个人版、团队版或企业版。\r\n- 如果您是个人用户，可以直接下载部署后免费使用，也可以自助授权或联系我们申请免费的个人授权码。\r\n\r\n# 面向教育的免费\r\n面向所有高校、教育、慈善、科研用途的域名限时免费授权。\r\n\r\n# 面向开源的免费\r\n我们深知能够坚持开源是一件很不容易和值得敬佩的事情，如果您是开源项目作者或开源社区成员，且我们的产品也正好符合您的需求，您可直接向我们申请免费的授权。\r\n\r\n我们由衷的敬佩开源界的大佬们，无私的奉献让众人前路更加平坦，但仅赞美和感谢并不能带来物质上的获得，更希望都能找到适合自己的商业模式，更长久的伟大下去。\r\n\r\n# 授权码获取\r\n您可以在我们的官网注册后进行自助授权：[https://zyplayer.com/#/wiki/selfAuth](https://zyplayer.com/#/wiki/selfAuth) ，支持个人版授权码免费获取、企业试用授权码获取，以及团队版、企业版授权码的付费获取和发票开具等。\r\n\r\n也可以添加技术客服的微信或QQ进行沟通了解详细信息\r\n\r\n在与客服沟通了解后，会依据您的购买信息生成授权码，将其填入到 `控制台 - 系统管理 - 商业授权页面` 的授权码输入框中即可激活授权，激活后您即可获取系统全部的功能项。\r\n\r\n![image.png](https://zyplayer.oss-cn-beijing.aliyuncs.com/zyplayerFiles/pageFiles/155/551/ZjvSDag7tqA4qHoCtZzCit.png)\r\n\r\n', 'toxic', '授权说明我们的软件都是按私有化部署的方式授权，而不是SaaS服务，数据完全私有存储，更安全放心！为了项目健康可持续发展、保持稳定的更新及系统安全性，我们选择了增加一个商业支持的版本，我们一直在朝着更好用、更现代化的方向努力着。如果项目符合您的审美，可以直接下载部署使用，如果软件功能符合您的预期，也欢迎购买授权来支持我们。版本及价格以下均为商业版本的授权，商业版也可直接下载部署并使用，开源版源码开放，无需任何授权即可使用。功能基础版个人版团队版企业版推荐旗舰版价格免费￥100 限免￥500￥3,000￥10,000帐号个数1个1个5个不限帐号不限帐号开放空间1个不限不限不限不限单页分享1个不限不限不限不限版权声明有有无无无新版更新权-6个月6个月1年10年老用户续费--六折六折-我们在提供了非常完备的功能的同时也制定了非常优惠的价格，且我们实行的是买断制，即购买后可永久使用，仅新版本的更新具有一定的时限，超过该时限之后如果新版本有功能是您想更新部署使用的，则需要再次购买授权。老用户续费可享受现价六折优惠商业版使用本地私有化部署，均不提供源代码以上均为含税的价格，均可开具电子发票和签署合同团队版可在5个帐号的基础上按￥100一个帐号的价格自由增加个人版申请免费授权不会强制您做任何事情，只需提供访问的域名或IP即可每份授权只包含一个域名的授权，一级域名不变的情况下最多支持修改3次二级域名我们会随着功能的增加不定期调整价格策略，如果软件符合需求请尽早与我们沟通哦各版本如何选择如果您是企业用户，我们推荐您选择企业版，没有帐号个数限制，同时也具有更长的新版更新权。如果您是初创团队，您可以选择按用户个数授权的团队版，满足当前人数暂且不是很多的需求场景。如果您是开源用户，我们提供有免费的授权优惠策略，满足条件可免费申请个人版、团队版或企业版。如果您是个人用户，可以直接下载部署后免费使用，也可以自助授权或联系我们申请免费的个人授权码。面向教育的免费面向所有高校、教育、慈善、科研用途的域名限时免费授权。面向开源的免费我们深知能够坚持开源是一件很不容易和值得敬佩的事情，如果您是开源项目作者或开源社区成员，且我们的产品也正好符合您的需求，您可直接向我们申请免费的授权。我们由衷的敬佩开源界的大佬们，无私的奉献让众人前路更加平坦，但仅赞美和感谢并不能带来物质上的获得，更希望都能找到适合自己的商业模式，更长久的伟大下去。授权码获取您可以在我们的官网注册后进行自助授权：https://zyplayer.com/#/wiki/selfAuth ，支持个人版授权码免费获取、企业试用授权码获取，以及团队版、企业版授权码的付费获取和发票开具等。也可以添加技术客服的微信或QQ进行沟通了解详细信息 添加客服微信 添加客服QQ在与客服沟通了解后，会依据您的购买信息生成授权码，将其填入到 控制台 - 系统管理 - 商业授权页面 的授权码输入框中即可激活授权，激活后您即可获取系统全部的功能项。', '2024-04-01 23:43:35', '2024-04-01 23:43:35', 0);
INSERT INTO `articles` VALUES (2, '11111', '关于zyplayer-doc项目', '2024-03-12 19:51:52', '|  |  | col1 |  |  | col2 | col3 |\n| - | - | :--- | - | - | ---- | ---- |\n|  |  |      |  |  |      |      |\n|  |  |      |  |  |      |      |\n|  |  |      |  |  |      |      |\n\n![18.jpg](http://localhost:3001/doc/1711969299155.jpg)\n\n建一个页面，命名为 tags。\n\n2. 设置页面类型\n3. ![](http://localhost:3001/doc/1711873475626.jpg)\n\n编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下：\n\n```scss\nclass=\"self-edit-btn save-btn\"\n```\n\nhttp://127.0.0.1:3001/kmsd-api\n\n![14.jpg](http://localhost:3001/doc/1711968139169.jpg)\n', 'toxic', '项目简介zyplayer-doc是一款适合企业和个人使用的WIKI知识库管理工具，提供在线化的知识库管理功能，专为私有化部署而设计，最大程度上保证企业或个人的数据安全，您可以完全以内网的方式来部署使用它。您也可以将其作为企业产品的说明文档来使用，我们支持一键将整个空间的内容开放到互联网，并提供有不同风格的开放文档页样式可供选择，省去您为了产品的说明文档而去定制开发一个系统的成本。也完全可以用它来替换VuePress、Docsify、Docute、Hexo、GitBook等文档网站生成器，当然，他们都是了不起的存在，都有着自己的特殊的强大的功能特性，某些特性在这里可能暂时无法得到满足，所以还需要您自行对比选择。但，何不来尝试折腾一下这个纯国产的工具项目呢~我们还提供有功能更加完备的闭源商业版本可供选择。体验地址：https://zyplayer.com在线文档：https://doc.zyplayer.com开源地址：https://gitee.com/dromara/zyplayer-doc开源版体验地址：https://op-doc.zyplayer.com注意当前所见WIKI为商业化的2.x版本，但你仍然可以免费的下载并部署到自己的服务器中使用 JAR格式的安装包文件可以直接下载，2.x闭源版使用文档 两个版本在基础功能上大致相同，闭源版本的在交互体验上做了重构升级，查看具体功能差异反馈与交流在使用过程中有任何问题和想法，欢迎随时提交 Issue，或者加入我们的微信交流群一起讨论交流，也可关注微信公众号了解产品最新资讯微信群员超过限制只能加好友拉进群，添加微信好友，回复：加群 即可Dromara-成员项目社区仓库地址：dromara开源社区站在巨人的肩膀上此项目基于以下开源软件构建后端： Spring-Boot、 MyBatis、 Druid、 MyBatis-Plus、 Hutool、 Fastjson、 Easy Excel、 Swagger、 Dubbo、 JGit、等等...前端： Vue、vite、element-ui、pinia、wangeditor、mavon-editor、qrcodejs2、vant、vue-router、axios、vue-hljs、brace、echarts、sql-formatter、vue-clipboard2、等等...', '2024-04-03 03:03:14', '2024-04-03 03:03:14', 1);
INSERT INTO `articles` VALUES (3, '文章2', '文章1描述', '2024-03-17 23:19:14', '# 文章1\n\n> 图片测试：\n\n![](http://localhost:3001/doc/1711865017798.jpg)\n', NULL, '文章1', '2024-04-01 22:49:52', '2024-04-01 22:49:52', 0);
INSERT INTO `articles` VALUES (4, '文章2', '文章2描述', '2024-03-17 23:19:14', '# 文章2\n\n```\n<img src=\"${data}\" alt=\"\">\n```\n\n<img src=\"http://localhost:3001/doc/1711873475626.jpg\">![](http://localhost:3001/doc/1711873475626.jpg)![](http://localhost:3001/doc/1711873475626.jpg)\n', NULL, '文章2', '2024-04-01 22:51:34', '2024-04-01 22:51:34', 0);
INSERT INTO `articles` VALUES (5, '文章3', '文章3描述', '2024-03-17 23:19:14', '# 文章3\n\n> 红红火火恍恍惚惚\n\n![image](http://localhost:3001/doc/1711883292238.jpg)    ![image](http://localhost:3001/doc/1711883433789.jpg)\n\n### 如图\n', NULL, '文章3', '2024-04-01 22:53:24', '2024-04-01 22:53:24', 0);
INSERT INTO `articles` VALUES (6, '实习报告1', '实习报告1内容', '2024-03-23 00:15:48', '# 实习报告1', NULL, NULL, '2024-05-08 13:40:54', '2024-05-08 13:40:54', 0);
INSERT INTO `articles` VALUES (7, '文章4', '文章4描述', '2024-03-17 23:19:14', '# 文章4', NULL, '文章1', '2024-04-02 00:56:11', '2024-04-02 00:56:15', 1);
INSERT INTO `articles` VALUES (8, '文章5', '文章5描述', '2024-03-17 23:19:14', '# 文章5', NULL, '文章2', '2024-04-02 00:56:17', '2024-04-02 00:56:19', 1);
INSERT INTO `articles` VALUES (9, '文章6', '文章6描述', '2024-03-17 23:19:14', '# 文章6', NULL, '文章3', '2024-04-02 00:56:23', '2024-04-02 00:56:25', 1);
INSERT INTO `articles` VALUES (18, 'ceshi111', '测试创建分组下文章', NULL, '![image](http://localhost:3001/doc/1711880924940.jpg)\n', NULL, NULL, '2024-04-01 22:46:34', '2024-04-01 22:46:34', 0);
INSERT INTO `articles` VALUES (19, '测试创建知识库下文章', '测试创建知识库下文章', NULL, NULL, NULL, NULL, '2024-03-27 03:02:00', '2024-03-27 03:02:00', 1);
INSERT INTO `articles` VALUES (20, '111', '111', NULL, NULL, NULL, NULL, '2024-04-01 23:08:37', '2024-04-01 23:08:37', 0);
INSERT INTO `articles` VALUES (21, '测试111', '测试创建知识库下文章', NULL, '![20.jpg](http://localhost:3001/doc/1711986247016.jpg)\n', NULL, NULL, '2024-04-01 23:46:14', '2024-04-01 23:46:14', 1);
INSERT INTO `articles` VALUES (22, '我想测试删除', '111', NULL, '# 君子藏器于身，待时而动\n\n### 5.1 准备\n\n**下载依赖：**\n\n```\nyarn add multer\nyarn add @types/multer\n```\n\n### 5.2\n\n### 5.3\n\n![image](http://localhost:3001/doc/1711880971147.jpg)\n', NULL, NULL, '2024-04-01 23:28:50', '2024-04-01 23:28:50', 0);
INSERT INTO `articles` VALUES (23, '你好', '测试在分组下的文档', NULL, NULL, NULL, NULL, '2024-03-27 11:34:54', '2024-03-27 11:34:54', 1);
INSERT INTO `articles` VALUES (24, '更新', '测试创建知识库下文章', NULL, '添加分类页面\n1.新建页面\n\n$ cd your-hexo-site\n$ hexo new page categories\n在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories。\n\n2.设置页面类型\n\n编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下：\n\n编辑主题配置文件，将menu中categories前的#去掉。\n\nmenu:\n#categories: /categories/ || fa fa-th\n在下载NEXT主题时，主题配置文件中menu默认有categories，只需将前面的#去掉即可。\n\n添加标签页面\n\n1. 新建页面\n\n![](http://localhost:3001/doc/1711873475626.jpg)\n\n$ cd your-hexo-site\n$ hexo new page tags\n在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags。\n\n2. 设置页面类型\n3. ![](http://localhost:3001/doc/1711873475626.jpg)\n\n编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下：\n\n```\nclass=\"self-edit-btn save-btn\"\n```\n\nhttp://127.0.0.1:3001/kmsd-api\n\n```---\n\n3. 修改菜单\n\n原文链接：https://blog.csdn.net/qq_45867247/article/details/1236966521111\n```\n', NULL, NULL, '2024-04-01 23:26:34', '2024-04-01 23:26:34', 0);
INSERT INTO `articles` VALUES (25, '222', '222', NULL, '### nihao\n', NULL, NULL, '2024-04-03 03:04:02', '2024-04-03 03:04:02', 1);
INSERT INTO `articles` VALUES (26, '测试创建实习1', '1213131', NULL, NULL, NULL, NULL, '2024-04-01 23:43:46', '2024-04-01 23:43:46', 0);
INSERT INTO `articles` VALUES (27, '测试知识库下文档11', '测试知识库下文档11测试知识库下文档11', NULL, NULL, NULL, NULL, '2024-03-28 10:56:48', '2024-03-28 10:56:48', 1);
INSERT INTO `articles` VALUES (28, '知识库1', '知识库1知识库1', NULL, NULL, NULL, NULL, '2024-03-28 10:57:50', '2024-03-28 10:57:50', 1);
INSERT INTO `articles` VALUES (29, '测试知识库下', '111', NULL, NULL, NULL, NULL, '2024-03-28 10:59:58', '2024-03-28 10:59:58', 1);
INSERT INTO `articles` VALUES (30, '创建1号1', '创建1号创建1号创建1号', NULL, NULL, NULL, NULL, '2024-04-01 23:21:30', '2024-04-01 23:21:30', 0);
INSERT INTO `articles` VALUES (31, '实习222', '实习222', NULL, '### 你好 21412222发的内容', NULL, NULL, '2024-03-30 17:40:09', '2024-03-30 17:40:09', 1);
INSERT INTO `articles` VALUES (32, NULL, '11111111111111111111111', NULL, NULL, NULL, NULL, '2024-03-30 16:36:14', '2024-03-30 16:36:17', 1);
INSERT INTO `articles` VALUES (33, '创建文章1', '创建文章1创建文章1创建文章1', NULL, NULL, NULL, NULL, '2024-04-01 23:24:29', '2024-04-01 23:24:29', 0);
INSERT INTO `articles` VALUES (40, '红红火火恍恍惚惚哈哈', '斤斤计较急急急急急急急急急急急急急', NULL, NULL, NULL, NULL, '2024-04-01 02:10:13', '2024-04-01 02:10:13', 1);
INSERT INTO `articles` VALUES (41, '天添加标签成功', '天添加标签成功天添加标签成功', NULL, NULL, NULL, NULL, '2024-04-01 02:12:33', '2024-04-01 02:12:33', 1);
INSERT INTO `articles` VALUES (42, '添加标签最重要##', '14241', NULL, NULL, NULL, NULL, '2024-04-01 02:13:59', '2024-04-01 02:13:59', 1);
INSERT INTO `articles` VALUES (43, '添加标签最重要', '1111', NULL, '```html\n<div data-v-3fa1a62e=\"\" data-v-7c5b78f0=\"\" class=\"abstract-item\">\n<i data-v-3fa1a62e=\"\" class=\"iconfont reco-sticky\"></i> \n<div data-v-3fa1a62e=\"\" class=\"title\"><!---->\n <a data-v-3fa1a62e=\"\" href=\"/toxicDocs/toxicBlogs/algorithm/js-structrue.html\" class=\"\">数据结构基础</a></div>\n <div data-v-3fa1a62e=\"\" class=\"abstract\"></div> <div data-v-1e62957f=\"\" data-v-3fa1a62e=\"\">\n	<i data-v-1e62957f=\"\" class=\"iconfont reco-account\"><span data-v-1e62957f=\"\">toxic</span></i>\n	<i data-v-1e62957f=\"\" class=\"iconfont reco-date\"><span data-v-1e62957f=\"\">2/16/2022</span></i> <!----> \n	<i data-v-1e62957f=\"\" class=\"tags iconfont reco-tag\">\n<span data-v-1e62957f=\"\" class=\"tag-item active\">数据结构</span></i>\n</div></div>\n```\n\n![16.jpg](http://localhost:3001/doc/1711945482243.jpg)\n\n---\n\n---\n\n---\n\n---\n\n11111111111111111111111111111111111\n\n![34.jpg](http://localhost:3001/doc/1711950061734.jpg)\n', NULL, NULL, '2024-04-03 02:57:15', '2024-04-03 02:57:15', 1);
INSERT INTO `articles` VALUES (45, '开发流程', '测试新增分组下文章11', NULL, '## 1.1 软件开发流程\n\n> 今天是星期一\n\n### 第 1 阶段: 需求分析\n\n完成产品原型、需求规格说明书的编写。\n\n产品原型，一般是通过网页(`html`)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。\n\n需求规格说明书， 一般来说就是使用 Word 文档来描述当前项目有哪些功能，每一项功能的需求及业务流程是什么样的，都会在文档中描述。\n\n### 第 2 阶段: 设计\n\n设计的内容包含 产品设计、UI界面设计、概要设计、详细设计、数据库设计。\n\n在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字段，字段类型都会在文档中描述清楚。\n\n### 第 3 阶段: 编码\n\n编写项目代码、并完成单元测试。\n\n作为软件开发工程师，我们主要的工作就是在该阶段， 对分配给我们的模块功能，进行编码实现。编码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。\n\n### 第 4 阶段: 测试\n\n在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。\n\n### 第 5 阶段: 上线运维\n\n在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发好的项目，部署在服务器上运行。\n\n我们作为软件开发工程师， 我们主要的任务是在编码阶段， 但是在一些小的项目组当中， 也会涉及到数据库的设计、测试等方面的工作。\n\n## 1.2 角色分工\n\n学习了软件开发的流程之后， 我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及各个角色的职责分工。\n\n\n| 岗位/角色  | 职责/分工                                  |\n| ---------- | ------------------------------------------ |\n| 项目经理   | 对整个项目负责，任务分配、把控进度         |\n| 产品经理   | 进行需求调研，输出需求调研文档、产品原型等 |\n| UI设计师   | 根据产品原型输出界面效果图                 |\n| 架构师     | 项目整体架构设计、技术选型等               |\n| 开发工程师 | 功能代码实现                               |\n| 测试工程师 | 编写测试用例，输出测试报告                 |\n| 运维工程师 | 软件环境搭建、项目上线                     |\n\n上述我们讲解的角色分工, 是在一个项目组中比较标准的角色分工, 但是在实际的项目中, 有一些项目组由于人员配置紧张, 可能并没有专门的架构师或测试人员, 这个时候可能需要有项目经理或者程序员兼任。\n\n## 1.3 软件环境\n\n在我们日常的软件开发中，会涉及到软件开发中的三套环境， 那么这三套环境分别是: 开发环境、测试环境、生产环境。 接下来，我们分别介绍一下这三套环境的作用和特点。\n\n### 开发环境(development)\n\n我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。\n\n比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地， 也可以安装在一台专门的服务器中， 这些应用软件仅仅在软件开发过程中使用， 项目测试、上线时，我们不会使用这套环境了，这个环境就是开发环境。\n\n### 测试环境(testing)\n\n当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境， 也就是测试环境，用于项目测试，一般外部用户无法访问。\n\n### 生产环境(production)\n\n当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对外提供服务，这个线上环境也称之为生产环境。\n\n> 拓展知识:\n>\n> 准生产环境：对于有的公司来说，项目功能开发好, 并测试通过以后，并不是直接就上生产环境。\n> 为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环境中, 测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的克隆体，准生产环境的服务器配置, 安装的应用软件(JDK、Tomcat、数据库、中间件 ...) 的版本都一样，这种环境也称为 \"仿真环境\"。\n>\n> ps.由于项目的性质和类型不同，有的项目可能不需要这个环境\n', NULL, NULL, '2024-05-08 15:07:37', '2024-05-08 15:07:37', 0);
INSERT INTO `articles` VALUES (46, 'yes', '11', NULL, NULL, NULL, NULL, '2024-04-02 20:48:00', '2024-04-02 20:48:00', 0);
INSERT INTO `articles` VALUES (47, '信息系统', '关于信息系统的一些知识点陈列', NULL, '## 1.2. 信息系统开发方法\n\n常用的开发方法包括 **结构化方法**、**面向对象方法**、**原型化方法**、**面向服务**的方法等。\n\n### 1.2.1. 结构化方法\n\n结构是指系统内各个组成要素之间的相互联系、相互作用的框架。结构化方法也称为 [生命周期法](https://www.zhihu.com/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)，是一种传统的信息系统开发方法，由 [结构化分析](https://www.zhihu.com/search?q=%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)（Structured Analysis，SA）、结构化设计（Structured Design，SD）和 [结构化程序设计](https://www.zhihu.com/search?q=%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)（Structured Programming，SP）三部分有机组合而成，其精髓是自顶向下、逐步求精和模块化设计。\n\n结构化方法假定待开发的系统是一个结构化的系统，其基本思想是将系统的生命周期划分为系统规划、系统分析、[系统设计](https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)、系统实施、[系统维护](https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E7%BB%B4%E6%8A%A4&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D) 等阶段。这种方法遵循 [系统工程原理](https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E5%8E%9F%E7%90%86&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)，按照事先设计好的程序和步骤，使用一定的 [开发工具](https://www.zhihu.com/search?q=%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)，完成规定的文档，在结构化和模块化的基础上进行信息系统的开发工作。结构化方法的开发过程一般是先把系统功能视为一个大的模块，再根据 [系统分析与设计](https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D) 的要求对其进行进一步的模块分解或组合。\n\n总结起来，结构化方法的主要特点列举如下：\n\n**(1)** **开发目标清晰化**：结构化方法的系统开发遵循“用户第一”的原则，开发中要保持与用户的沟通，取得与用户的共识，这使得信息系统的开发建立在可靠的基础之上。\n\n**(2)** **开发工作阶段化**：结构化方法每个阶段的工作内容明确，注重对开发过程的控制。\n\n**(3)** **开发文档规范化**：结构化方法每个阶段工作完成后，要按照要求完成相应的文档，以保证各个工作阶段的衔接与系统维护工作的便利。\n\n**(4)** **设计方法结构化**：在系统分析与设计时，从整体和全局考虑，自顶向下分解；在系统实现时，根据设计的要求，先编写各个具体的功能模块，然后 [自底向上](https://www.zhihu.com/search?q=%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D) 逐步实现整个系统。\n\n结构化方法是目前最成熟，应用较广泛的一种工程化方法，它特别适合于数据处理领域的问题，但不适应于规模较大、比较复杂的系统开发，这是因为结构化方法具有以下不足和局限性：\n\n①　开发周期长\n\n②　难以适应需求变化\n\n③　很少考虑数据结构\n\n### 1.2.2. 面向对象方法\n\n面向对象（OO）方法认为，客观世界是由各种对象组成的，任何事物都是对象。与结构化方法类似，OO 方法也划分阶段，但其中的系统分析、系统设计和系统实现三个阶段之间已经没有“缝隙”。也就是说，这三个阶段的界限变得不明确。\n\nOO 方法使系统的描述及[信息模型](https://www.zhihu.com/search?q=%E4%BF%A1%E6%81%AF%E6%A8%A1%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)的表示与客观实体相对应，符合人们的思维习惯，有利于系统开发过程中用户与开发人员的交流和沟通，缩短开发周期。OO 方法可以普遍适用于各类信息系统的开发，但是，OO 方法也存在明显的不足。例如，必须依靠一定的 OO 技术支持，在大型项目的开发上具有一定的局限性，不能涉足系统分析以前的开发环节。\n\n一些大型信息系统的开发，通常是将结构化方法和 OO 方法结合起来。首先，使用结构化方法进行自顶向下的整体划分；然后，自底向上地采用 OO 方法进行开发。因此，结构化方法和 OO 方法仍是两种在系统开发领域中相互依存的、不可替代的方法。\n\n### 1.2.3. 原型化方法\n\n**结构化方法和 [面向对象方法](https://www.zhihu.com/search?q=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D) 有一个共同点**，即在系统开发初期必须明确系统的功能要求，确定**系统边界**。从工程学角度来看，这是十分自然的：解决问题之前必须明确要解决的问题是什么。然而，对于信息系统建设而言，明确问题本身不是一件轻松的事情。\n\n原型化方法也称为[快速原型法](https://www.zhihu.com/search?q=%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)。它是一种根据用户初步需求，利用系统开发工具，快速地建立一个[系统模型](https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)展示给用户，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法。\n\n**1.** **原型的概念和分类**\n\n从原型是否实现功能来分，可分为水平原型和[垂直原型](https://www.zhihu.com/search?q=%E5%9E%82%E7%9B%B4%E5%8E%9F%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)两种。水平原型也称为[行为原型](https://www.zhihu.com/search?q=%E8%A1%8C%E4%B8%BA%E5%8E%9F%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)，用来探索预期系统的一些特定行为，并达到细化需求的目的。水平原型通常只是功能的导航，但并未真实实现功能。水平原型主要用在界面上，垂直原型也称为[结构化原型](https://www.zhihu.com/search?q=%E7%BB%93%E6%9E%84%E5%8C%96%E5%8E%9F%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)，实现了一部分功能。垂直原型主要用在复杂的算法实现上。\n\n从原型的最终结果来分，可分为[抛弃式原型](https://www.zhihu.com/search?q=%E6%8A%9B%E5%BC%83%E5%BC%8F%E5%8E%9F%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)和演化式原型。抛弃式原型也称为[探索式原型](https://www.zhihu.com/search?q=%E6%8E%A2%E7%B4%A2%E5%BC%8F%E5%8E%9F%E5%9E%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)，是指达到预期目的后，原型本身被抛弃。抛弃式原型主要用在解决需求不确定性、二义性、不完整性、含糊性等；演化式原型为开发增量式产品提供基础，逐步将原型演化成最终系统。主要用在必须易于升级和优化的场合，特别适用于 Web 项目。\n\n**2.** **原型法的开发过程**\n\n![](https://picx.zhimg.com/80/v2-716ba0bb110bb9c04be36260600ab290_720w.webp?source=1def8aca)\n\n**3.** **原型法的特点**\n\n**原型法的特点主要体现在以下几个方面：**\n\n**原型法**可以使系统开发的周期缩短、成本和风险降低、速度加快，**获得较高的综合开发效益。**\n\n2. **原型法是以用户为中心来开发系统的**，用户参与的程度大大提高，开发的系统符合用户的需求，因而增加了用户的满意度，提高了系统开发的成功率。\n3. 由于用户参与了系统开发的全过程，对系统的功能和结构容易理解和接受，有利于系统的移交，**有利于系统的运行与维护**。\n\n**原型法也不是万能的，它有不足之处，主要体现在以下两个方面：**\n\n* **开发的环境要求高：**例如，开发人员和用户的素质、系统开发工具、软硬件设备等。原型法**成败的关键及效率的高低，在于原型构建的速度**。\n* **管理水平要求高：**系统的开发**缺乏统一的规划和开发标准**，难以对系统的开发过程进行控制。\n\n> 原型法的优点主要在于能更有效地确认用户需求。\n> 从直观上来看，原型法适用于哪些需求不明确的系统开发。\n> 事实上，对于分析层面难度大、技术层面难度不大的系统，适合于原型法开发；\n> 而对于技术层面困难远大于分析层面的系统，则不宜用原型法。\n\n### 1.2.4. 面向服务的方法\n\nOO 的应用构建在[类和对象](https://www.zhihu.com/search?q=%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)之上，随后发展起来的建模技术将相关对象按照业务功能进行分组，就形成了构件的概念。对于[跨构件](https://www.zhihu.com/search?q=%E8%B7%A8%E6%9E%84%E4%BB%B6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)的功能调用，则采用接口的形式暴露出来。**进一步将接口的定义与现实进行解耦，则催生了服务和面向服务（Service-Oriented，SO）**的开发方法。\n\n从应用的角度来看，组织内部、组织之间各种应用系统的互相通信和互操作性直接影响着组织对信息的掌握程度和处理速度。如何使信息系统快速响应需求与环境变化，**提高系统可[复用性](https://www.zhihu.com/search?q=%E5%A4%8D%E7%94%A8%E6%80%A7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2745388602%7D)、信息资源共享和系统之间的互操作性**，成为影响信息化建设效率的关键问题，而 SO 的思维方式恰好满足了这种需求。\n\n目前，SO 方法是一个较新的领域，许多研究和实践还有待进一步深入。但是，**它代表着不拘泥于具体技术实现方式的一种新的系统开发思想**，**已经成为信息系统建设的大趋势**，越来越多的组织开始实施 SO 的信息系统。\n', NULL, NULL, '2024-04-04 19:29:23', '2024-04-04 19:29:23', 1);
INSERT INTO `articles` VALUES (48, 'ER图对应关系', '理解数据库表实体之间的关系', NULL, '## ER图是什么\n\n实体关系图（Entity-Relationship Diagram，简称ER图）是一种图形化的工具，用于表示数据库中不同实体之间的关系和连接。ER图是数据库设计中常用的一种方法，旨在**帮助人们可视化和理解数据模型、实体之间的联系以及数据流动**。\n\n在ER图中，实体用矩形表示，属性用椭圆或矩形中的文本表示，关系用菱形表示，线条表示实体之间的连接和关系。ER图提供了一种直观的方式来描述实体、属性和关系之间的结构，从而使数据库设计人员、开发人员和其他相关人员更容易共享和沟通数据库的设计意图。\n\n### 1. 实体是什么\n\n上面描述中我们提到了实体，那么实体到底是什么呢？\n\n“实体” 是指现实世界中独立存在并具有独特属性的事物或对象。每个实体都可以在数据库中表示为一个表，而每个表的行则对应于实体的具体实例。\n\n实体可以是物理对象，如人、车辆、产品等，也可以是抽象概念，如订单、课程、事件等。每个实体通常具有一些属性，这些属性用于描述实体的特征。例如，一个 “人” 实体可能具有属性如姓名、年龄、性别等。\n\n### 2. 关系\n\n那么实体间的关系，有哪些呢\n\n![image.png](http://localhost:3001/doc/1712135171967.png)\n\n在数据库设计中，一对一（One-to-One）、一对多（One-to-Many）和多对多（Many-to-Many）是常见的实体关系类型，用于描述不同实体之间的连接和关系。下面我会详细解释每种关系，并举例说明：\n\n**一对一关系**（One-to-One）：\n\n![c0a0c42850a44a8abfc6bafea9691372.png](http://localhost:3001/doc/1712134226067.png)\n\n一对一关系表示一个实体在一个表中与另一个实体在另一个表中存在唯一对应关系。每个实体在一个表中只能与一个实体在另一个表中关联，反之亦然。这种关系常用于描述具有一一对应关系的情况，如身份证与个人信息之间的关系。\n\n具体到数据库中的具体表现为：\n\n举例：假设有一个 “人员” 表和一个 “身份证” 表，每个人员只有一个唯一的身份证号，每个身份证号也只对应一个人员。\n\n**一对多关系**（One-to-Many）：\n\n一对多关系表示一个实体在一个表中可以与多个实体在另一个表中关联。每个实体在一个表中可以对应多个实体在另一个表中，但每个实体在另一个表中只能关联一个实体。这种关系常用于描述主表与从表之间的关系，如客户与订单之间的关系。\n\n具体到数据库中的具体表现为：\n\n举例：假设有一个 “客户” 表和一个 “订单” 表，每个客户可以拥有多个订单，但每个订单只属于一个客户。\n\n**多对多关系**（Many-to-Many）：\n多对多关系表示多个实体在一个表中可以与多个实体在另一个表中关联。这种关系需要使用一个中间表来建立连接，中间表中存储了两个实体之间的对应关系。这种关系常用于描述多对多关联的情况，如学生与课程之间的关系。\n\n具体到数据库中的具体表现为：\n\n举例：假设有一个 “学生” 表和一个 “课程” 表，一个学生可以选择多门课程，而一门课程也可以被多名学生选择。这种关系需要使用一个中间表来记录学生和课程之间的对应关系。\n', NULL, NULL, '2024-04-03 17:06:15', '2024-04-03 17:06:15', 1);
INSERT INTO `articles` VALUES (49, 'Vue3的设计目标', '关于Vue3三年来为出现的问题的解决思路', NULL, '## 一、设计目标\n\n不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下 `Vue3` 之前我们或许会面临的问题\n\n* 随着功能的增长，复杂组件的代码变得越来越难以维护\n* 缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制\n* 类型推断不够友好\n* `bundle` 的时间太久了\n\n而 `Vue3` 经过长达两三年时间的筹备，做了哪些事情？\n\n我们从结果反推\n\n* 更小\n* 更快\n* `TypeScript` 支持\n* `API` 设计一致性\n* 提高自身可维护性\n* 开放更多底层功能\n\n一句话概述，就是更小更快更友好了\n\n### 更小\n\n`Vue3` 移除一些不常用的 `API`\n\n引入 `tree-shaking`，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了\n\n### 更快\n\n主要体现在编译方面：\n\n* `diff` 算法优化\n* 静态提升\n* 事件监听缓存\n* `SSR` 优化\n\n下篇文章我们会进一步介绍\n\n### 更友好\n\n`vue3` 在兼顾 `vue2` 的 `options API` 的同时还推出了 `composition API`，大大增加了代码的逻辑组织和代码复用能力\n\n这里代码简单演示下：\n\n存在一个获取鼠标位置的函数\n\n```js\nimport { toRefs, reactive } from \'vue\';\nfunction useMouse() {\n    const state = reactive({ x:0,y:0 });\n    const update = e => {\n        state.x = e.pageX;\n        state.y = e.pageY;\n    }\n    onMounted(()=>{\n        window.addEventListener(\'mousemove\', update);\n    })\n    onUnmounted(()=>{\n        window.removeEventListener(\'mousemove\', update);\n    })\n\n    return toRefs(state);\n}\n```\n\n我们只需要调用这个函数，即可获取 `x`、`y` 的坐标，完全不用关注实现过程\n\n试想一下，如果很多类似的第三方库，我们只需要调用即可，不必关注实现过程，开发效率大大提高\n\n同时，`VUE3` 是基于 `typescipt` 编写的，可以享受到自动的类型定义提示\n\n## 三、优化方案\n\n`vue3` 从很多层面都做了优化，可以分成三个方面：\n\n* 源码\n* 性能\n* 语法 API\n\n### 源码\n\n源码可以从两个层面展开：\n\n* 源码管理\n* TypeScript\n\n#### 源码管理\n\n`vue3` 整个源码是通过 `monorepo` 的方式维护的，根据功能将不同的模块拆分到 `packages` 目录下面不同的子目录中\n\n![](https://static.vue-js.com/d7c32520-5c58-11eb-ab90-d9ae814b240d.png)\n\n这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性\n\n另外一些 `package`（比如 `reactivity` 响应式库）是可以独立于 `Vue` 使用的，这样用户如果只想使用 `Vue3` 的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 `Vue`\n\n#### TypeScript\n\n`Vue3` 是基于 `typeScript` 编写的，提供了更好的类型检查，能支持复杂的类型推导\n\n### 性能\n\n`vue3` 是从什么哪些方面对性能进行进一步优化呢？\n\n* 体积优化\n* 编译优化\n* 数据劫持优化\n\n这里讲述数据劫持：\n\n在 `vue2` 中，数据劫持是通过 `Object.defineProperty`，这个 API 有一些缺陷，并不能检测对象属性的添加和删除\n\n```js\nObject.defineProperty(data, \'a\',{\n  get(){\n    // track\n  },\n  set(){\n    // trigger\n  }\n})\n```\n\n尽管 `Vue` 为了解决这个问题提供了 `set` 和 `delete` 实例方法，但是对于用户来说，还是增加了一定的心智负担\n\n同时在面对嵌套层级比较深的情况下，就存在性能问题\n\n```js\ndefault {\n  data: {\n    a: {\n      b: {\n          c: {\n          d: 1\n        }\n      }\n    }\n  }\n}\n```\n\n相比之下，`vue3` 是通过 `proxy` 监听整个对象，那么对于删除还是监听当然也能监听到\n\n同时 `Proxy` 并不能监听到内部深层次的对象变化，而 `Vue3` 的处理方式是在 `getter` 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归\n\n### 语法 API\n\n这里当然说的就是 `composition API`，其两大显著的优化：\n\n* 优化逻辑组织\n* 优化逻辑复用\n\n#### 逻辑组织\n\n一张图，我们可以很直观地感受到 `Composition API` 在逻辑组织方面的优势\n\n![](https://static.vue-js.com/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png)\n\n相同功能的代码编写在一块，而不像 `options API` 那样，各个功能的代码混成一块\n\n#### 逻辑复用\n\n在 `vue2` 中，我们是通过 `mixin` 实现功能混合，如果多个 `mixin` 混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰\n\n而通过 `composition` 这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可\n\n同样是上文的获取鼠标位置的例子\n\n```js\nimport { toRefs, reactive, onUnmounted, onMounted } from \'vue\';\nfunction useMouse(){\n    const state = reactive({x:0,y:0});\n    const update = e=>{\n        state.x = e.pageX;\n        state.y = e.pageY;\n    }\n    onMounted(()=>{\n        window.addEventListener(\'mousemove\',update);\n    })\n    onUnmounted(()=>{\n        window.removeEventListener(\'mousemove\',update);\n    })\n\n    return toRefs(state);\n}\n```\n\n组件使用\n\n```js\nimport useMousePosition from \'./mouse\'\nexport default {\n    setup() {\n        const { x, y } = useMousePosition()\n        return { x, y }\n    }\n}\n```\n\n可以看到，整个数据来源清晰了，即使去编写更多的 `hook` 函数，也不会出现命名冲突的问题\n\n## 参考文献\n\n* https://juejin.cn/post/6850418112878575629#heading-5\n* https://vue3js.cn/docs/zh\n', NULL, NULL, '2024-04-07 15:22:44', '2024-04-07 15:22:44', 1);
INSERT INTO `articles` VALUES (50, 'Vue3的Proxy API', 'Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？', NULL, '## 一、Object.defineProperty\n\n定义：`Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n\n### 为什么能实现响应式\n\n> 通过 defineProperty 两个属性，get 和 set\n\n#### get\n\n属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。\n\n#### set\n\n属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined。\n\n下面通过代码展示：\n\n定义一个响应式函数 `defineReactive`\n\n```\nfunction update() {\n    app.innerText = obj.foo\n}\n\nfunction defineReactive(obj, key, val) {\n    Object.defineProperty(obj, key, {\n        get() {\n            console.log(`get ${key}:${val}`);\n            return val\n        },\n        set(newVal) {\n            if (newVal !== val) {\n                val = newVal\n                update()\n            }\n        }\n    })\n}\n```\n\n:j: ：调用`defineReactive`，数据发生变化触发update方法，实现数据响应式\n\n```js\nconst obj = {}\ndefineReactive(obj, \'foo\', \'\')\nsetTimeout(()=>{\n    obj.foo = new Date().toLocaleTimeString()\n},1000)\n```\n\n:j: 在对象存在多个 `key` 情况下，需要进行遍历\n\n```js\nfunction observe(obj) {\n    if (typeof obj !== \'object\' || obj == null) {\n        return\n    }\n    Object.keys(obj).forEach(key => {\n        defineReactive(obj, key, obj[key])\n    })\n}\n```\n\n:j: 如果存在嵌套对象的情况，还需要在`defineReactive`中进行递归\n\n```js\nfunction defineReactive(obj, key, val) {\n    observe(val)\n    Object.defineProperty(obj, key, {\n        get() {\n            console.log(`get ${key}:${val}`);\n            return val\n        },\n        set(newVal) {\n            if (newVal !== val) {\n                val = newVal\n                update()\n            }\n        }\n    })\n}\n```\n\n:j: 当给 `key` 赋值为对象的时候，还需要在 `set` 属性中进行递归\n\n```js\nset(newVal) {\n    if (newVal !== val) {\n        observe(newVal) // 新值是对象的情况\n        notifyUpdate()\n    }\n}\n```\n\n### `defineProperty` 的问题\n\n上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题。**现在对一个对象进行删除与添加属性操作，无法劫持到。**\n\n```js\nconst obj = {\n    foo: \"foo\",\n    bar: \"bar\"\n}\nobserve(obj)\ndelete obj.foo // no ok\nobj.jar = \'xxx\' // no ok\n```\n\n**当我们对一个数组进行监听的时候，对 push pop等方法都无效。主要是索引的失效。**\n\n```js\nconst arrData = [1,2,3,4,5];\narrData.forEach((val,index)=>{\n    defineProperty(arrData,index,val)\n})\narrData.push() // no ok\narrData.pop()  // no ok\narrDate[0] = 99 // ok\n```\n\n可以看到数据的 `api` 无法劫持到，从而无法实现数据响应式，\n\n所以在 `Vue2` 中，增加了 `set`、`delete` API，并且对数组 `api` 方法进行一个重写\n\n还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题\n\n### 小结\n\n* 检测不到对象属性的添加和删除\n* 数组 `API` 方法无法监听到\n* 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题。\n\n## 二、proxy\n\n`Proxy` 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了\n\n在 `ES6` 系列中，我们详细讲解过 `Proxy` 的使用，就不再述说了\n\n下面通过代码进行展示：\n\n定义一个响应式方法 `reactive`\n\n```js\nfunction reactive(obj) {\n    if (typeof obj !== \'object\' && obj != null) {\n        return obj\n    }\n    // Proxy相当于在对象外层加拦截\n    const observed = new Proxy(obj, {\n        get(target, key, receiver) {\n            const res = Reflect.get(target, key, receiver)\n            console.log(`获取${key}:${res}`)\n            return res\n        },\n        set(target, key, value, receiver) {\n            const res = Reflect.set(target, key, value, receiver)\n            console.log(`设置${key}:${value}`)\n            return res\n        },\n        deleteProperty(target, key) {\n            const res = Reflect.deleteProperty(target, key)\n            console.log(`删除${key}:${res}`)\n            return res\n        }\n    })\n    return observed\n}\n```\n\n```js\nconst state = reactive({\n    foo: \'foo\'\n})\n// 1.获取\nstate.foo // ok\n// 2.设置已存在属性\nstate.foo = \'fooooooo\' // ok\n// 3.设置不存在属性\nstate.dong = \'dong\' // ok\n// 4.删除属性\ndelete state.dong // ok\n```\n\n**测试嵌套对象情况，这时候发现就不那么 OK 了。没有办法嵌套响应**\n\n```js\nconst state = reactive({\n    bar: { a: 1 }\n})\n\n// 设置嵌套对象属性\nstate.bar.a = 10 // no ok\n```\n\n如果要解决，需要在 `get` 之上再进行一层代理\n\n```js\nfunction reactive(obj) {\n    if (typeof obj !== \'object\' && obj != null) {\n        return obj\n    }\n    // Proxy相当于在对象外层加拦截\n    const observed = new Proxy(obj, {\n        get(target, key, receiver) {\n            const res = Reflect.get(target, key, receiver)\n            console.log(`获取${key}:${res}`)\n            return isObject(res) ? reactive(res) : res\n        },\n    return observed\n}\n```\n\n## 三、总结\n\n`Object.defineProperty` 只能遍历对象属性进行劫持\n\n```js\nfunction observe(obj) {\n    if (typeof obj !== \'object\' || obj == null) {\n        return\n    }\n    Object.keys(obj).forEach(key => {\n        defineReactive(obj, key, obj[key])\n    })\n}\n```\n\n`Proxy` 直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的\n\n`Proxy` 可以直接监听数组的变化（`push`、`shift`、`splice`）\n\n`Proxy` 有多达 13 种拦截方法,不限于 `apply`、`ownKeys`、`deleteProperty`、`has` 等等，这是 `Object.defineProperty` 不具备的。正因为 `defineProperty` 自身的缺陷，导致 `Vue2` 在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外 `set`、`delete` 方法）\n\n但是 `Proxy` 不兼容 IE，也没有 `polyfill`, `defineProperty` 能支持到 IE9\n', NULL, NULL, '2024-05-08 13:33:56', '2024-05-08 13:33:56', 0);
INSERT INTO `articles` VALUES (51, 'JavaScript基础', '前端技能：JavaScript基础知识点', NULL, '## 1. 数组扁平化\n\n1. `Infinity` 无穷 ；`flat()` 默认展开一层\n2. **字符串通过正则：**`replace(/\\[]\\]/g)` 全局格式 `\\\\g`\n3. 递归 将每个元素 `push` 到新的数组中\n4. `reduce(pre, cur, initValue)`  配合递归\n\n```\nlet newArr = []\nfunction alip(arr) {\n  for (let item of arr) {\n    if (Array.isArray(item)) alip(item)\n    else newArr.push(item)\n  }\n}\n\nalip([1, 2, [3, 4, [5, 6], 10], 11])\n```\n\n```\nconst arr = [1, 2, [3, 4, [5, 6], 10], 11]\nfunction clip(arr) {\n  return arr.reduce((pre, cur) => {\n    return pre.concat(Array.isArray(cur) ? clip(cur) : cur)\n  }, [])\n}\nclip(arr)\n```\n\n## 2. 拷贝\n\n1. **浅拷贝基本数据类型是复制值；引用数据类型时是拷贝引用地址。**\n2. **栈存放基本数据类型以及引用数据类型的指针。堆存放引用数据类型的真实数据。**\n3. **bigint - ES11 新增**\n\n### 浅拷贝\n\n```\n// 浅拷贝\nconst obj = {\n  name: \"张三\",\n  age: 8,\n  pal: [\"王五\", \"王六\", \"王七\"], // 赋值引用类型的指针\n}\nfunction shallowCopy(object) {\n  const shallowObj = {}\n  for (const key in object) {\n    shallowObj[key] = object[key]\n  }\n  return shallowObj\n}\nconst shallow = shallowCopy(obj)\nshallow.pal.push(\"19\")\nconsole.log(obj) // { name: \'张三\', age: 8, pal: [ \'王五\', \'王六\', \'王七\', \'19\' ] }\n```\n\n### 深拷贝\n\n**使用不同的方式配合递归将引用数据类型进行深刻复制**\n\n```\nconst obj = {\n  // 原数据，包含字符串、对象、函数、数组等不同的类型\n  name: \"test\",\n  main: { a: 1, b: 2 },\n  fn: function () {},\n  friends: [1, 2, 3, [22, 33]]\n}\nfunction deepCopy(target) {\n  if (typeof target === \"object\") { // 判断数组还是对象\n    const newTarget = Array.isArray(target) ? [] : Object.create(null)\n    for (const key in target) { // 遍历\n      newTarget[key] = deepCopy(target[key]) // 递归\n    }\n    return newTarget\n  } else {\n    return target\n  }\n}\n```\n\n## 3. 防抖节流\n\n### 防抖\n\n> **短时间内大量触发同一事件；**\n>\n> **只在最后一次事件触发后延迟执行一次函数。**\n\n**采取方式：在事件触发后设置定时器，再次触发则重置定时器。**\n\n```\n/**\n * 防抖\n * @param {*} fn 定时器到时的回调函数\n * @param {*} delay 延时的秒数\n */\nfunction debounce(fn, delay) {\n  let timer = null\n  return function (...args) {\n    if (timer) clearTimeout(timer) // 清除定时器\n    timer = setTimeout(() => {\n      timer = null // 重置定时器\n      fn.apply(this, args)\n    }, (delay + \"\") | 0 || 1000 / 60)\n  }\n}\nfunction fn() {\n  console.log(\"执行函数\")\n}\nconst debounce1 = debounce(fn, 100)\n\ndebounce1(1)\ndebounce1(1)\ndebounce1(1)\n```\n\n### 节流\n\n## 4. 布局\n\n### 两栏布局\n\n**一般是左侧固定，右侧自适应**\n\n1. **浮动**\n\n左侧固定宽度，使用浮动 `float: left` ；右侧使用  `margin-left` 撑出内容块做展示。\n\n2. `flex`\n\n父容器采取 `flex`布局；左侧固定宽度，右侧使用`flex: 1` 自适应\n\n### 三栏布局\n\n**一般是左右两侧固定，中间自适应**\n\n1. 浮动 + `margin`\n\n```\n<div class = \"left\"></div>\n<div class = \"right\"></div>\n<div class = \"middle\"></div>\n```\n\n左侧使用 `float: left`  右侧使用 `float: right` 需要把 `middle` 放在最后，不然 `right` 就第二层了。\n\n```\n.left {\n  float: left;\n  width: 200px;\n  background-color: red;\n}\n.right {\n  float: right;\n  width: 200px;\n  background-color: yellow;\n}\n.middle {\n  margin-left: 200px;\n  margin-right: 200px;\n}\n```\n\n2. **绝对定位**\n\n使用绝对定位将左右两边固定，中间占满使用`margin`\n\n3. **浮动 + 负**`margin`  更加复杂\n\n需要给中间使用双层标签，左右两边都使用负 `margin` 向上偏移\n\n4. `flex`  或者  `grid`\n\n## 5. 省略号\n\n1. **使用伪元素**\n\n```\n.text {\n  position: relative;\n}\n.text::after {\n  content: \"...\"; /* 省略号是放在文本最后面的 */\n  width: 1em;    /* 设置伪元素的宽度为1em，是为了遮盖的时候正好遮盖中原来的一个字的大小*/\n  position: absolute;\n  right: 0;\n  bottom: 0;\n}\n```\n\n2. **使用旧版弹性盒子**\n\n```\n.text {\n  overflow: hidden;\n  display: -webkit-box;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 2;\n}\n```\n\n3. **单行文字省略**\n\n```\n.text {\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n```\n', NULL, NULL, '2024-05-05 13:21:37', '2024-05-05 13:21:37', 1);
INSERT INTO `articles` VALUES (52, 'ES6', '关于JavaScript在ES6上的一些运用', NULL, '## 一、扩展运算符的应用\n\nES6通过扩展元素符`...`，好比 `rest` 参数的逆运算，将一个数组转为用逗号分隔的参数序列\n\n```js\nconsole.log(...[1, 2, 3])\n// 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n\n[...document.querySelectorAll(\'div\')]\n// [<div>, <div>, <div>]\n```\n\n1. 主要用于函数调用的时候，将一个数组变为参数序列\n\n```js\nfunction push(array, ...items) {\n  array.push(...items);\n}\n\nfunction add(x, y) {\n  return x + y;\n}\n\nconst numbers = [4, 38];\nadd(...numbers) // 42\n```\n\n2. 可以将某些数据结构转为数组\n\n```js\n[...document.querySelectorAll(\'div\')]\n```\n\n3. 能够更简单实现数组复制\n\n```js\nconst a1 = [1, 2];\nconst [...a2] = a1;\n// [1,2]\n```\n\n4. 数组的合并也更为简洁了\n\n```js\nconst arr1 = [\'a\', \'b\'];\nconst arr2 = [\'c\'];\nconst arr3 = [\'d\', \'e\'];\n[...arr1, ...arr2, ...arr3]\n// [ \'a\', \'b\', \'c\', \'d\', \'e\' ]\n```\n\n**注意**：通过扩展运算符实现的是 <u>浅拷贝</u>，修改了引用指向的值，会同步反映到新数组\n\n下面看个例子就清楚多了\n\n```js\nconst arr1 = [\'a\', \'b\',[1,2]];\nconst arr2 = [\'c\'];\nconst arr3  = [...arr1,...arr2]\narr[1][0] = 9999 // 修改arr1里面数组成员值\nconsole.log(arr[3]) // 影响到arr3,[\'a\',\'b\',[9999,2],\'c\']\n```\n\n5. **扩展运算符可以与解构赋值结合起来，用于生成数组**\n\n```js\nconst [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest  // [2, 3, 4, 5]\n\nconst [first, ...rest] = [];\nfirst // undefined\nrest  // []\n\nconst [first, ...rest] = [\"foo\"];\nfirst  // \"foo\"\nrest   // []\n```\n\n注意：如果将扩展运算符用于数组赋值，**只能放在参数的最后一位**，否则会报错\n\n```js\nconst [...butLast, last] = [1, 2, 3, 4, 5];\n// 报错\n\nconst [first, ...middle, last] = [1, 2, 3, 4, 5];\n// 报错\n```\n\n6. 可以将字符串转为真正的数组\n\n```javascript\n[...\'hello\']\n// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]\n```\n\n7. 定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组\n\n```js\nlet nodeList = document.querySelectorAll(\'div\');\nlet array = [...nodeList];\n\nlet map = new Map([\n  [1, \'one\'],\n  [2, \'two\'],\n  [3, \'three\'],\n]);\n\nlet arr = [...map.keys()]; // [1, 2, 3]\n```\n\n如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错\n\n```javascript\nconst obj = {a: 1, b: 2};\nlet arr = [...obj]; // TypeError: Cannot spread non-iterable object\n```\n\n## 二、构造函数新增的方法\n\n关于构造函数，数组新增的方法有如下：\n\n- Array.from()\n- Array.of()\n\n### Array.from()\n\n将两类对象转为真正的数组：类似数组的对象和可遍历`（iterable）`的对象（包括 `ES6` 新增的数据结构 `Set` 和 `Map`）\n\n```js\nlet arrayLike = {\n    \'0\': \'a\',\n    \'1\': \'b\',\n    \'2\': \'c\',\n    length: 3\n};\nlet arr2 = Array.from(arrayLike); // [\'a\', \'b\', \'c\']\n```\n\n还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组\n\n```js\nArray.from([1, 2, 3], (x) => x * x)\n// [1, 4, 9]\n```\n\n### Array.of()\n\n用于将一组值，转换为数组\n\n```js\nArray.of(3, 11, 8) // [3,11,8]\n```\n\n没有参数的时候，返回一个空数组\n\n当参数只有一个的时候，实际上是指定数组的长度\n\n参数个数不少于 2 个时，`Array()`才会返回由参数组成的新数组\n\n```js\nArray() // []\nArray(3) // [, , ,]\nArray(3, 11, 8) // [3, 11, 8]\n```\n', NULL, NULL, '2024-05-05 19:20:19', '2024-05-05 19:20:19', 1);
INSERT INTO `articles` VALUES (53, 'JavaScript手写系列', '比如深拷贝、new、防抖节流之类。', NULL, '## 1. 函数柯里化\n\n> **将多个参数的函数 转换为 接收单个参数的函数链式调用 的技术。**\n\n```\n// 先看实现的效果\nconst add = (a, b, c) => a + b + c\nconst newFn = curry(fn)\nnewFn(1, 2, 3) // 调用的都是curried函数\nnewFn(1, 2)(3)\n```\n\n```\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      // length 是JS函数对象的一个属性值，该值是指 “该函数有多少个必须要传入的参数”，即形参的个数\n      // 形参的数量不包括剩余参数个数，仅包括 “第一个具有默认值之前的参数个数”\n      return fn.apply(this, args)\n    } else {\n      return function (...args2) {\n        return curried.apply(this, [...args, ...args2]) // 同args.concat(args2)\n      }\n    }\n  }\n}\n```\n\n**作用：函数复用 和 延迟执行。**\n\n## 2. 手写 `new`\n\n* 构造函数作为参数第一项\n* 构造函数的`prototype` 原型对象指向实例对象。\n* 更改 构造函数执行时的`this` 指向，并获取执行结果。\n\n```\nfunction _new(...args) {\n  const Constructor = args[0]\n  const obj = Object.create(Constructor.prototype)\n  const result = Constructor.apply(obj, args.slice(1))\n  return result instanceOf object ? result : obj\n}\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n  return () => {}\n}\n\nconsole.log(_new(Person, \"jack\", 18))  // [Function (anonymous)]\nconsole.log(new Person(\"mary\", 20))    // [Function (anonymous)]\n```\n\n## 3. 手写 `call`\n\n**前提：**\n\n1. `call` 是由函数来调用的：`Fn.call(obj, a, b)` 。\n2. **调用 **`call` 需要**立即执行** `Fn(a, b)` 然后将 `this` 指向到 `obj` 。\n\n```\nFunction.prototype.myCall = function (context, ...argsArray) {\n  context = context || window // 上下文如果是undefined的话就默认全局执行上下文\n  context.fn = this // 定义fn属性 值为函数add\n  const res = context.fn(...argsArray) // 调用add函数。因为是context调用的，所以this指向context\n  delete context.fn\n  return res // 需要立即执行函数并返回执行值\n}\nfunction add (a, b) {\n  console.log(this) // { name: \'lucky\', fn: [Function: add] }\n  return a + b\n}\nconst obj = { name: \'lucky\' }\nadd.myCall(obj, 1, 2)\n```\n\n**重点：**\n\n1. **传递的是参数列表**\n2. **立即执行函数**\n3. **只是临时改变 this 指向**\n\n**只需要让对象执行该函数，就可以改变 this 值给这个对象了。**\n\n### 手写 apply\n\n**调用方式：Fn.apply( obj, [1, 2, 3] )**\n\n**同样需要立即执行函数和临时改变指向** 与 call 只是传递参数的不同\n\n```\nFunction.prorotype.myApply = (context, argsArray) => {\n  context = context || window\n  let fn = Symbol() // 唯一的值\n  context[fn] = this\n  const res = context[fn](...argsArray) // 传递参数当然是一个一个的\n  delete context[fn]\n  return res\n}\n```\n\n**🔴** 只是临时改变 this 指向一次。第二次调用该函数的时候，this 就指向全局了。\n\n### 手写 bind\n\n**👹** 比较**特别**\n\n1. **传递参数列表和 call 一样**\n2. **改变 this 指向后不会立刻执行函数**\n3. **返回一个永久改变 this 指向的函数。**\n\n**配合柯里化， 分别传入参数**\n\n```\nFunction.prototype.myBind = function (context, ...argsArray) {\n  // 可能argsArray只是部分参数\n  const fn = this\n  return function Fn() {\n    // 可能会传递剩余参数\n    const allArgs = [...arguments, ...argsArray]\n    return fn.apply(context, allArgs)\n  }\n}\n\nfunction add(a, b) {\n  console.log(this, a + b)\n  return a + b\n}\nconst obj = { name: \"callLucky\" }\nconst bound = add.myBind(obj, 4)\nbound(2)\n```\n\n## 4. 实现 `AJAX` 请求\n\n```\nconst ajaxRequest = (url, method = \"GET\", data = null) => {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHTTPRequest()\n    xhr.open(method, url)\n    // 监听readyState的改变\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState !== 4) return\n      if (xhr.status === 200) resolve(xhr.responseText)\n      else reject(new Error(xhr.statusText))\n    }\n    xhr.onerror = () => {\n      reject(new Error(xhr.statusText))\n    }\n    xhr.setRequestHeader(\'Accept\', \'application/json\')\n    xhr.send(data)\n  })\n}\n```\n\n**❓** 注意：在 node 环境中是没有 XMLHTTPRequest 构造函数的。直接使用会导致 `XMLHTTPRequest is not defined` 错误。\n\n**❗️** 需要下载依赖 `xmlhttprequest`\n\n```\n// 声明后才可以使用\nconst XMLHttpRequest = require(\"xmlhttprequest\").XMLHttpRequest\n```\n\n## 5. 迭代器\n\n**前提：对象无法使用 for...of 来进行迭代。原因是 for...of 只适用有迭代器的 数组 类数组 Map Set 等可迭代对象的。**\n\n**原理：JS 引擎是通过对象是否拥有属性 Symbol.iterator 来判断的。**\n\n```\n[][Symbol.iterator] // [Function: values]\n{}[Symbol.iterator] // Undefined 对象中没有该属性\n```\n\n**迭代器是返回**`next()` 方法的对象。每次调用 next 方法都会返回一个类似 `{ value: xx, done: false }` 的对象。\n\n```\nlet person = {\n  name: \"jack\",\n  technology: [\"css\", \"js\", \"html\", \"vue\"]\n}\n// 直接使用for...of会报错：person is not iterable\n// 给person对象新增一个属性[Symbol.iterator]\nperson[Symbol.iterator] = () => {\n  const keys = Object.keys(person) // [name, technology]\n  let i = 0 // 存放调用next的次数变量 0 1\n  const length = keys.length // i为2的时候就没有值了 2\n  return i < length ? {\n    value: person[keys[i++]],\n    done: false\n  } : { value: undefined, done: true }\n}\n```\n\n**可以使用生成器**：yield 用来控制每次调用时返回的值。\n\n**yield 语句在生成一个值后会暂停函数的执行状态，以便在下一次请求值时继续执行。**\n\n```\nperson[Symbol.iterator] = function* () {\n  let arr = Object.entries(person)\n  for (let i = 0; i < arr.length; i++) {\n    yield arr[i]\n  }\n}\n```\n\n**原理：** 这个生成器对象具有一个特殊的 `__next__()` 方法，用于请求生成器的下一个值。直到遇到 `yield` 暂停。\n', NULL, NULL, '2024-05-05 13:22:51', '2024-05-05 13:22:51', 1);
INSERT INTO `articles` VALUES (54, '白屏', '关于白屏出现的原因和解决方案', NULL, '## 白屏\n\n1. **从屏幕空白到显示第一个页面的时间 - 白屏时间**\n2. **页面渲染的时间越短，感知页面速度越快，就可以极大的提高用户体验，减少用户的跳出，提升页面的留存率。**\n\n### 白屏过程\n\n> 即输入 url 到页面画面展示的过程。\n\n1. 查看浏览器缓存；如果缓存有，会直接显示页面内容。\n2. 发送 http 前需要域名解析 DNS；解析获取到对应的 ip 地址。\n3. 浏览器向服务器发起 tcp 连接，与浏览器建立 tcp 三次握手。\n4. 握手成功后：浏览器向服务器发送 http 请求，请求数据包。\n5. 服务器收起请求，处理将数据返回给浏览器。\n6. 浏览器收到 http 响应。\n7. 读取页面内容，浏览器渲染，解析 html\n8. 生成 dom 树，解析 css 样式，js 交互，渲染显示页面。\n\n**JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行。**\n\n### 性能优化\n\n1. DNS 缓存优化；DNS 预加载策略；稳定的 DNS 服务器\n2. TCP 网络链路优化\n3. 服务器处理优化\n4. 浏览器下载、解析、渲染页面优化：\n\n**不使用内联的 JS：或者配合 defer async 使用。异步加载 JS**\n\n**关键 CSS 代码可以内联到 HTML 中，CSS 可以更快下载，然后在结束 HTML 下载后就可以马上渲染了。页面渲染时间提前，缩短首屏渲染时间。**\n\n**延迟首屏不需要的图片的加载**\n', NULL, NULL, '2024-05-07 12:19:21', '2024-05-07 12:19:21', 1);
INSERT INTO `articles` VALUES (55, 'Web worker', '关于web worker开启JavaScript多线程的使用', NULL, '## Web Worker\n\n**JS 单线程：为了防止多个线程同时操作 DOM，带来渲染冲突问题，所以 JS 执行器被设计为单线程。（同一时间只能执行一个任务）**\n\n**WebWorker 是 HTML5 规范的一部分。允许我们在 JS 主线程之外开辟新的 Worker 线程。新的 Worker 线程与 JS 主线程是相对独立的。**\n\n**当有大量运算任务时就可以交予 Worker 线程去执行，执行完毕后将结果返回给 JS 主线程（postMessage）。这样 JS 主线程只需要专注于业务逻辑了。**\n\n**从而减少了阻塞时间，提高了运行效率，页面流畅度和用户体验自然而然也提高了。**\n\n**worker 线程的特点之一就是沙箱环境：无法访问与主线程有关的变量以及 dom 元素等等。**\n\nWorker 线程上下文也存在一个顶级对象`self`。\n\n### 1. **创建 worker**\n\n```javascript\nconst worker = new Worker(path, options)\n// path: 有效的脚本地址\n```\n\n### 2. 主线程与 Worker 线程的消息传递\n\n主线程与 worker 线程都是通过 postMessage方法来发送消息，以及监听 message 事件来接收消息。\n\n**主线程：**\n\n```javascript\n// main.js 主线程操作\nconst worker = new Worker(\'worker.js\') // 创建Worker线程\nworker.addEventListener(\'message\', e => { // message事件是用来接收消息的。\n  // e.data 即worker线程发送回来的消息\n})\n// 给worker线程发送消息\nworker.postMessage(\'主线程发出的消息\')\n```\n\n**worker 线程：**\n\n```javascript\nself.addEventListener(\'message\', e => {\n  // e.data 拿到主线程发出的消息\n  self.postMessage(\'worker线程发出消息\')\n})\nexport default self;\n```\n\n**worker 线程之间传递是值而不是地址。**`<span class=\"ne-text\">postMessage()</span>` 传递的数据可以是由[结构化克隆](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FGuide%2FDOM%2FThe_structured_clone_algorithm)算法处理的任何值或 JavaScript 对象，包括循环引用。\n\n### 3. 关闭 worker 线程\n\n关闭之后：worker 线程当前的 Event Loop 中的任务会继续执行。\n\n```javascript\n// main主线程\nworker.terminate() // 主线程主动关闭连接，那么之后尽管worker线程还执行postMessage也不会再接收到。\n\n// worker线程\nself.close() // worker进行执行当前 Event Loop; 如果继续调用 postMessage() 方法，主线程还是能通过监听message事件收到消息的。\n```\n\n### 4. worker 线程引用其他 js 文件\n\n我们可以在 worker 线程中利用 importScripts 方法加载我们需要的 js 文件，而且，通过此方法加载的 js 文件不受同源策略约束！\n\n### Web Worker 的引入\n\n**主要是为了改善前端应用的响应性，使其能够更好地处理一些计算密集型任务，而不是将 JavaScript 彻底转变为多线程编程语言。**\n\n**JavaScript 的主要应用领域仍然是处理用户界面和用户交互。**\n', NULL, NULL, '2024-05-07 16:56:11', '2024-05-07 16:56:11', 1);
INSERT INTO `articles` VALUES (56, 'setTimeout 运行机制', 'setTimeout 和 setInterval 的运行机制，以及建议使用', NULL, '### setTimeout 运行机制\n\n1. 指定某个函数或代码在 多少 **毫秒之后** 执行。\n2. 返回一个整数代表定时器的编号。可以通过 clear 指定编号来清除定时器。\n3. **无论 setTimeout 的执行时间是 0 还是更多，都是在同步函数之后执行。**\n\n```javascript\nconsole.log(1);\nsetTimeout(function () {\n    console.log(2);\n}, 0);\nconsole.log(3);\n// 1 3 2\n```\n\n**执行机制：**每隔 300ms 会将 fn 加入到任务队列中。\n\n```javascript\nsetTimeout(fn, 300) \n```\n\n### setInterval 运行机制\n\n**同样作为异步任务。当计时结束的时候就会将回调函数放入到任务队列中等待执行。**\n\n**但是如果前面的任务在定时器到时还没完成的话，定时器会将回调再次放入任务队列中。**\n\n**会导致：**\n\n1. 某些间隔会被跳过\n2. 可能多个定时器会连续执行\n\n![image.png](http://localhost:3001/doc/1715056775605.png)\n\n![image.png](http://localhost:3001/doc/1715056799235.png)\n', NULL, NULL, '2024-05-07 12:40:07', '2024-05-07 12:40:07', 1);
INSERT INTO `articles` VALUES (57, 'Vue2的model属性', '在 vue2 中使用 model 和 v-model 指令实现子组件向父组件传递数据。', NULL, '## 使用 model 和 v-model 指令\n\n> 在 vue2 中使用 model 和 v-model 指令实现子组件向父组件传递数据\n>\n> 可参考：[Vue 中使用 model 属性 - huyadi - 博客园](https://www.cnblogs.com/yadi001/p/16851483.html)\n\n1. **子组件代码**：接收一些 props 属性，一个 v-model 以及绑定了 change 事件。\n\n```html\n<template>\n    <gxx-select\n      <!-- ...props属性 -->\n      @change=\"changeValue\"\n      <!-- selectValue 就是 props 的 value-->\n      v-model=\"selectValue\">\n    </gxx-select>\n</template>\n```\n\n2. **子组件中配置 model，并触发两个自定义事件**\n\n```javascript\nexport default {\n  model: {\n    prop: \'value\', // 用来接收值的prop名称\n    event: \'change\' // 当Value发生变化时触发\n	},\n  props: {\n    value: {\n      type: [String, Array, Number]\n    }\n  },\n  data() {\n    return {\n      selectValue: this.value // 有watch省略了\n    }\n  }\n  methods: {\n    changeValue(val) {\n      this.$emit(\'change\', val)\n      // 父组件可以使用change来获取新值\n    }\n  }\n}\n```\n\n3. **父组件中使用 v-model 指令：绑定子组件的 value prop 和  change event。**\n   这样当子组件触发 change 事件的时候，v-model 绑定的变量会自动更新。\n   change 事件触发传递的 val，实则就是传递给父组件 v-model 的 spaceType 了。\n\n```html\n<dic-grid\n  style=\"width: 280px;\"\n  placeholder=\"请选择场所类型\"\n  dic-name=\"PMP_SPACE_TYPE\"\n  v-model=\"queryData.spaceType\">\n</dic-grid>\n```\n\n## 补充：\n\n**实则这种 v-model 的使用相当于：**\n\n```html\n<dic-grid\n  :value=\"queryData.spaceType\"\n  @change = value = $event>\n</dic-grid>\n```\n\n**参考链接：**[妙用 computed 拦截 v-model，面试管都夸我细 - 掘金](https://juejin.cn/post/7277089907974422588)\n\n[组件 v-model | Vue.js](https://cn.vuejs.org/guide/components/v-model.html#handling-v-model-modifiers)\n', NULL, NULL, '2024-05-07 17:31:37', '2024-05-07 17:31:37', 1);
INSERT INTO `articles` VALUES (58, 'TypeScript属性', '学习TS中的各类属性如类、继承、接口等等', NULL, '## 1. 概念\n\n:facepunch: : **1. 什么是对象？**\n\n:page_with_curl: : 任何事物到了程序中就变成了一个对象。程序是对事物的抽象。\n\n1. 操作浏览器要使用`window`对象\n2. 操作网页要使用`document`对象\n3. 操作控制台要使用`console`对象\n\n**一切操作都要通过对象。**\n\n:punch: : **2. 属性与方法**\n\n:page_with_curl: : 在程序中所有的对象都被分成了两个部分数据和功能。\n\n以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。\n\n**数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。**\n\n## 2. 类\n\n**类是对象的抽象，对象是类的实例。**要创建对象，必须先定义类。可以把类理解为对象的模型。\n\n### 2.1 属性\n\n```ts\n// 使用class关键字定义一个类\nclass Person{\n    // 使用static关键字可以定义类属性【静态属性】：不需要新建对象就可以使用的属性\n    // 实例属性\n    name:string = \"孙悟空\";\n    age:number = 17;\n    static sex : string = \"male\";\n}\n// 实例化\nconst person1 = new Person();\nconsole.log(person1); // 访问不到静态属性【类属性】\nconsole.log(person1.name,person1.age);// 实例属性可以访问到。\n```\n\n:punch: **【类属性】需要通过类去访问。**`Person.sex` 不用实例化就可以访问。\n\n:punch: **【只读属性`readonly`】: 无法被修改。** 要是和`static`连用，需要写在`static`后面。\n\n### 2.2 方法\n\n```ts\n// 使用class关键字定义一个类\nclass Person{\n    sayHello(){\n        console.log(\"hello\");\n    };\n    static staticHello(){\n        console.log(\"staticFunction\");\n    }\n}\n// 实例化\nconst person1 = new Person();\nconsole.log(person1); // 访问不到静态方法【类方法】\nPerson.staticHello(); // 使用类直接访问。\n```\n\n### 2.3 构造函数\n\n:punch: 一个类可能创建多个对象。**希望这个类用来创建不同的对象**，而不是一模一样的对象。\n\n```ts\n// 使用class关键字定义一个类\nclass Dog {\n    name: string;\n    age: number;\n\n    bark() {\n        alert(\"汪汪汪\");\n    };\n\n    // 调用new关键字就是执行构造函数。\n    constructor(name:string,age:number) {\n        // 构造函数中有this关键字。就表示当前实例，我们可以通过this向新建的对象中添加属性。\n        this.name = name;\n        this.age = age;\n    }\n}\n\nconst dog = new Dog(\"旺财\",2);\nconsole.log(dog);\n```\n\n:punch: 构造函数的简化形式\n\n```ts\nclass Dog{\n    constructor(public name:string,public age:number){}\n    // 方法体中可以是空的。\n}\n```\n\n## 3. 继承\n\n:page_facing_up: 1. **继承是面向对象的又一个特性**；通过继承可以将其他类中的属性和方法引入到当前类中。\n\n### 3.1 梗概\n\n```ts\n// 立即执行函数\n(function(){\n  \n})();\n```\n\n```ts\n// 引入继承\n(function () {\n    // 使用class关键字定义一个类\n    class Dog {\n        name: string;\n        age: number;\n\n        bark() {\n            console.log(\"汪汪汪\");\n        };\n\n        // 调用new关键字就是执行构造函数。\n        constructor(name:string,age:number) {\n            // 构造函数中有this关键字。就表示当前实例，我们可以通过this向新建的对象中添加属性。\n            this.name = name;\n            this.age = age;\n        }\n    }\n\n    class Cat{\n        name: string;\n        age: number;\n\n        bark() {\n            console.log(\"喵喵喵\");\n        };\n\n        // 调用new关键字就是执行构造函数。\n        constructor(name:string,age:number) {\n            // 构造函数中有this关键字。就表示当前实例，我们可以通过this向新建的对象中添加属性。\n            this.name = name;\n            this.age = age;\n        }\n    }\n    const dog = new Dog(\"旺财\",6);\n    const cat = new Cat(\"喵喵\",5);\n    dog.bark();\n    cat.bark();\n})();\n```\n\n:paintbrush: 观察：两个类的大部分代码几乎一模一样。可以将一样的代码抽象为一个`Animal`类。由`dog`和`cat`去继承`Animal`的属性与方法。\n\n```ts\n(function () {\n    // 使用class关键字定义一个类\n    class Animal {\n        name: string;\n        age: number;\n\n        bark() {\n            console.log(\"Animal在叫\");\n        };\n\n        // 调用new关键字就是执行构造函数。\n        constructor(name: string, age: number) {\n            // 构造函数中有this关键字。就表示当前实例，我们可以通过this向新建的对象中添加属性。\n            this.name = name;\n            this.age = age;\n        }\n    }\n\n    class Dog extends Animal {\n\n    }\n\n    class Cat extends Animal {\n\n    }\n\n    const dog = new Dog(\"旺财\", 6);\n    const cat = new Cat(\"喵喵\", 5);\n    console.log(dog);\n    console.log(cat);\n    dog.bark();\n    cat.bark();\n})();\n\n```\n\n:point_right: **继承作用：** 通过继承可以将多个类中共有的代码写在一个父类中，这样只需要写一次即可让所有的子类都同时拥有父类中的属性和方法。\n\n:interrobang: 子类也可以写父类没有的属性与方法。是独有的。\n\n:interrobang: 但是执行`bark()`函数时都变为了一样的`Animal在叫`\n\n:punch: **重写：继承过程中子类的方法会覆盖掉父类的同名方法。**\n\n```ts\nclass Dog extends Animal {\n    bark() {\n        console.log(\"汪汪汪！\")\n    }\n}\n```\n\n### 3.2 `super`\n\n:page_with_curl: `super`表示就是当前类的父类。\n\n```ts\nclass Dog extends Animal {\n    bark() {\n        super.bark();// 其实引用的就是父类的bark函数。\n    }\n}\n```\n\n:interrobang: 子类写构造函数时，会覆盖掉父类的构造函数。所以必须调用父类的构造函数。\n\n```ts\nclass Dog extends Animal {\n    // 2. 子类独有的属性也需要声明。\n    sex:string;\n    constructor(name:string,age:number,sex:string) {\n        super(name,age);  // 1. 父类的构造函数中有属性name和age。所以需要在子类的构造函数也声明。\n        // 3. 再添加上子类需要的属性。\n        this.sex = sex;\n    };\n    bark() {\n        console.log(\"汪汪汪！\")\n    }\n}\n```\n\n## 4. 接口\n\n### 4.1 抽象类\n\n:page_with_curl: 按道理来说：父类如`Animal`也是一个类，也可以用来创建对象。但是我们不希望它被用来创建对象，它是作为一个超类被继承。\n\n:punch: 在超类的前面加上 **`abstact`** 关键字将它变为抽象类。抽象类不能被用来创建对象。\n\n:punch: **抽象类就是专门用来继承的类。** 抽象类中可以添加抽象方法【也是在函数前面加上关键字`abstact`，且没有方法体】。具体实现必须由子类实行。\n\n```ts\n// 使用class关键字定义一个类\nabstract class Animal {\n    name: string;\n\n    // 调用new关键字就是执行构造函数。\n    constructor(name: string) {\n        // 构造函数中有this关键字。就表示当前实例，我们可以通过this向新建的对象中添加属性。\n        this.name = name;\n    };\n\n    abstract bark(): void;\n}\n```\n\n:interrobang: 定义抽象方法时必须 添加返回值类型。如：` abstract bark(): void;` 表示返回值为 `void`。\n\n```ts\n// 子类继承\nclass Dog extends Animal {\n    bark() {\n        console.log(\"汪汪汪！\")\n    }\n}\n\nclass Cat extends Animal {\n    bark() {\n        console.log(\"喵喵喵！\")\n    }\n}\n```\n\n### 4.2 接口\n\n:page_with_curl: 定义一个类的结构。`interface`关键字开头。同时接口也可以当成类型声明使用。类型别名和接口很相似。区别如下：\n\n```tsx\n// 接口：\ninterface Animal{\n    name: string\n}\ninterface Bear extends Animal{   // 继承扩展Bear的类型\n    honey: bolean\n}\nconst bear : Bead = {\n    name: \'whine\',\n    honey: false\n}\n// 类型别名\ntype Animal = {\n    name: string\n}\ntype Bear = Animal & {\n    honey: boolean\n}\nconst bear : Bear = {\n    name: \'whine\',\n    honey: false\n}\n\n// 定义相同的接口，不同的类型。可以算是添加字段。\ninterface MyWindow{\n    name: string\n}\ninterface MyWindow{\n    count: number\n}\nconst w: MyWindow = {\n    name: \'kal\',\n    count: 4\n}\n// 定义相同的类型，会导致重复标识符报错。\n```\n\n:punch: **接口可以重复声明。不会覆盖，会添加上去。**\n\n:punch: **接口中所有方法都是抽象方法，所有属性都没有具体值。**\n\n```ts\n// 有点像抽象类。\n// 使用关键字定义接口\ninterface MyInterface{\n    // 接口属性声明\n    name:string;\n    // 接口方法是抽象方法，要写返回值，不写方法体\n    bark():void;\n}\n\n// 抽象类也是类。需要class\nabstract class Animal{\n    // 声明属性\n    name:string;\n    // 声明属性之后需要写构造函数。\n    protected constructor(name:string) {\n        this.name = name;\n    }\n    // 只要加上abstract关键字变为抽象方法，才可以不写方法体。\n    // 一般的方法还是要写的，但接口中天然是抽象方法。\n    abstract bark():void;\n}\n```\n\n:punch: 接口就是定义一个规范，只要你实现了我的接口，就是符合我的规范和标准。\n\n**实现接口：**\n\n```ts\nclass MyClass implements MyInterface{\n    // implements all members 只有属性与方法。\n    name: string;\n    // 需要为属性书写构造函数。\n    constructor(name:string) {\n        this.name = name;\n    }\n    // 实现接口的抽象方法\n    bark(): void {\n        console.log(this.name+\"在叫\");\n    }\n}\nconst dog = new MyClass(\"旺财\");\ndog.bark();  // 输出 “旺财在叫”\n```\n\n## 5. 泛型\n\n### 5.1 属性封装\n\n:punch: 现在属性是在对象中设置的。属性可以通过对象被任意地修改。导致对象中的数据变得非常不安全。\n\n```ts\nclass MyClass implements MyInterface{\n    name: string;\n    constructor(name:string) {\n        this.name = name;\n    }\n}\nconst dog = new MyClass(\"旺财\");\ndog.name = \"喵咪咪\";\nconsole.log(dog); // 输出 Object { name: \"喵咪咪\" }\n```\n\n:page_facing_up: 1. 使得类中的属性变为私有属性，就不会被任意修改。\n\n:page_facing_up: 2. 私有属性之后，添加 `getter,setter【属性的存取器】`方法，使得属性可以被访问和修改。\n\n:page_facing_up: 3. 访问属性时会自执行get方法。\n\n```ts\n// 属性name的读取。是函数但是可以通过 xxx.name 属性的形式来读取。\nget name(){\n    return this._name;\n}\n```\n\n:arrow_double_down: 使用`getter setter`方式：同 `java `中的形式。\n\n:arrow_double_down: 使用`get 属性|set 属性`方式：\n\n```\n\n```\n\n:punch: 使用 **Alt+Insert** 可以快捷键添加。\n\n```ts\nclass MyClass implements MyInterface{\n    constructor(public _name:string) {\n    }\n    // 实现接口的抽象方法\n    bark(): void {\n        console.log(this._name+\"在叫\");\n    }\n\n    get name(): string {\n        console.log(\"get name()被执行啦\");\n        return this._name;\n    }\n\n    set name(value: string) {\n        this._name = value;\n    }\n}\nconst dog = new MyClass(\"旺财\");\nconsole.log(dog.name)  // 输出 get name()被执行啦 旺财\n// 通过访问属性name，即为调用get name()函数。\n```\n\n### 5.2 泛型\n\n:punch: 在定义函数或者类时，如果类型不明确就可以使用泛型。\n\n```ts\nfunction fn<T>(a:T):T{\n    // fn后的<T>是定义T类型。形参为T类型，返回类型也为T类型\n    // T类型是尚不明确的类型。\n    return a;\n}\n// 调用该函数时，会自动判断参数的类型。\nfn(10);\nfn<string>(\"hello\");\n```\n\n:punch: 可以指定多个泛型。\n\n```ts\nfunction fn<T,K>(a:T,b:K):T{\n}\n```\n\n:punch: 泛型也可以是类。\n\n```ts\ninterface Animal{\n    name:string;\n}\n// 指定的形参是T类型；T是继承接口的子类。\nfunction fn<T extends Animal>(a:T):string{\n    return a.name;\n}\n```\n\n```ts\nclass MyClass<T>{\n    // 是你的属性希望使用泛型。就必须在类声明\n    name:T;\n    constructor(name:T){\n        this.name = name;\n    }\n}\n```\n', NULL, NULL, '2024-05-07 18:28:31', '2024-05-07 18:28:31', 1);
INSERT INTO `articles` VALUES (59, 'Vue3的Proxy API', 'Vue3引入的新的响应式系统', NULL, '## 一、Object.defineProperty\n\n定义：`Object.defineProperty()` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n\n### 为什么能实现响应式\n\n> 通过 defineProperty 两个属性，get 和 set\n\n#### get\n\n属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。\n\n#### set\n\n属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined。\n\n下面通过代码展示：\n\n定义一个响应式函数 `defineReactive`\n\n```\nfunction update() {\n    app.innerText = obj.foo\n}\n\nfunction defineReactive(obj, key, val) {\n    Object.defineProperty(obj, key, {\n        get() {\n            console.log(`get ${key}:${val}`);\n            return val\n        },\n        set(newVal) {\n            if (newVal !== val) {\n                val = newVal\n                update()\n            }\n        }\n    })\n}\n```\n\n:j: ：调用`defineReactive`，数据发生变化触发update方法，实现数据响应式\n\n```js\nconst obj = {}\ndefineReactive(obj, \'foo\', \'\')\nsetTimeout(()=>{\n    obj.foo = new Date().toLocaleTimeString()\n},1000)\n```\n\n:j: 在对象存在多个 `key` 情况下，需要进行遍历\n\n```js\nfunction observe(obj) {\n    if (typeof obj !== \'object\' || obj == null) {\n        return\n    }\n    Object.keys(obj).forEach(key => {\n        defineReactive(obj, key, obj[key])\n    })\n}\n```\n\n:j: 如果存在嵌套对象的情况，还需要在`defineReactive`中进行递归\n\n```js\nfunction defineReactive(obj, key, val) {\n    observe(val)\n    Object.defineProperty(obj, key, {\n        get() {\n            console.log(`get ${key}:${val}`);\n            return val\n        },\n        set(newVal) {\n            if (newVal !== val) {\n                val = newVal\n                update()\n            }\n        }\n    })\n}\n```\n\n:j: 当给 `key` 赋值为对象的时候，还需要在 `set` 属性中进行递归\n\n```js\nset(newVal) {\n    if (newVal !== val) {\n        observe(newVal) // 新值是对象的情况\n        notifyUpdate()\n    }\n}\n```\n\n### `defineProperty` 的问题\n\n上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题。**现在对一个对象进行删除与添加属性操作，无法劫持到。**\n\n```js\nconst obj = {\n    foo: \"foo\",\n    bar: \"bar\"\n}\nobserve(obj)\ndelete obj.foo // no ok\nobj.jar = \'xxx\' // no ok\n```\n\n**当我们对一个数组进行监听的时候，对 push pop等方法都无效。主要是索引的失效。**\n\n```js\nconst arrData = [1,2,3,4,5];\narrData.forEach((val,index)=>{\n    defineProperty(arrData,index,val)\n})\narrData.push() // no ok\narrData.pop()  // no ok\narrDate[0] = 99 // ok\n```\n\n可以看到数据的 `api` 无法劫持到，从而无法实现数据响应式，\n\n所以在 `Vue2` 中，增加了 `set`、`delete` API，并且对数组 `api` 方法进行一个重写\n\n还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题\n\n### 小结\n\n* 检测不到对象属性的添加和删除\n* 数组 `API` 方法无法监听到\n* 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题。\n\n## 二、proxy\n\n`Proxy` 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了\n\n在 `ES6` 系列中，我们详细讲解过 `Proxy` 的使用，就不再述说了\n\n下面通过代码进行展示：\n\n定义一个响应式方法 `reactive`\n\n```js\nfunction reactive(obj) {\n    if (typeof obj !== \'object\' && obj != null) {\n        return obj\n    }\n    // Proxy相当于在对象外层加拦截\n    const observed = new Proxy(obj, {\n        get(target, key, receiver) {\n            const res = Reflect.get(target, key, receiver)\n            console.log(`获取${key}:${res}`)\n            return res\n        },\n        set(target, key, value, receiver) {\n            const res = Reflect.set(target, key, value, receiver)\n            console.log(`设置${key}:${value}`)\n            return res\n        },\n        deleteProperty(target, key) {\n            const res = Reflect.deleteProperty(target, key)\n            console.log(`删除${key}:${res}`)\n            return res\n        }\n    })\n    return observed\n}\n```\n\n```js\nconst state = reactive({\n    foo: \'foo\'\n})\n// 1.获取\nstate.foo // ok\n// 2.设置已存在属性\nstate.foo = \'fooooooo\' // ok\n// 3.设置不存在属性\nstate.dong = \'dong\' // ok\n// 4.删除属性\ndelete state.dong // ok\n```\n\n**测试嵌套对象情况，这时候发现就不那么 OK 了。没有办法嵌套响应**\n\n```js\nconst state = reactive({\n    bar: { a: 1 }\n})\n\n// 设置嵌套对象属性\nstate.bar.a = 10 // no ok\n```\n\n如果要解决，需要在 `get` 之上再进行一层代理\n\n```js\nfunction reactive(obj) {\n    if (typeof obj !== \'object\' && obj != null) {\n        return obj\n    }\n    // Proxy相当于在对象外层加拦截\n    const observed = new Proxy(obj, {\n        get(target, key, receiver) {\n            const res = Reflect.get(target, key, receiver)\n            console.log(`获取${key}:${res}`)\n            return isObject(res) ? reactive(res) : res\n        },\n    return observed\n}\n```\n\n## 三、总结\n\n`Object.defineProperty` 只能遍历对象属性进行劫持\n\n```js\nfunction observe(obj) {\n    if (typeof obj !== \'object\' || obj == null) {\n        return\n    }\n    Object.keys(obj).forEach(key => {\n        defineReactive(obj, key, obj[key])\n    })\n}\n```\n\n`Proxy` 直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的\n\n`Proxy` 可以直接监听数组的变化（`push`、`shift`、`splice`）\n\n`Proxy` 有多达 13 种拦截方法,不限于 `apply`、`ownKeys`、`deleteProperty`、`has` 等等，这是 `Object.defineProperty` 不具备的。正因为 `defineProperty` 自身的缺陷，导致 `Vue2` 在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外 `set`、`delete` 方法）\n\n但是 `Proxy` 不兼容 IE，也没有 `polyfill`, `defineProperty` 能支持到 IE9\n', NULL, NULL, '2024-05-08 13:42:25', '2024-05-08 13:42:25', 1);
INSERT INTO `articles` VALUES (60, '绿色能源发展', '实现可持续未来的关键途径', NULL, '随着全球气候变化和环境问题日益严重，绿色能源发展已成为各国关注的焦点。绿色能源，也称为可再生能源，是指对环境友好、不会耗尽的能源，如太阳能、风能、水能、生物质能等。本文将探讨绿色能源的重要性、发展现状、挑战以及未来发展趋势。\n\n## 一、绿色能源的重要性\n\n1. 环境保护：绿色能源可以减少温室气体排放，降低空气和水污染，保护生态环境。\n2. 能源安全：可再生能源分布广泛，有助于减少对化石能源的依赖，提高能源供应的安全性。\n3. 经济效益：随着技术进步，绿色能源的成本逐渐降低，有望成为更具竞争力的能源形式。\n4. 社会责任：发展绿色能源是各国履行国际减排义务、实现可持续发展的体现。\n\n## 二、绿色能源发展现状\n\n1. 太阳能：太阳能光伏发电和热发电技术逐渐成熟，应用范围不断扩大。\n2. 风能：风电装机容量逐年增长，海上风电成为未来发展的重要方向。\n3. 水能：水力发电是世界上最大的可再生能源发电方式，具有较高的经济效益。\n4. 生物质能：生物质发电、生物质燃料和生物质成型燃料等产业初具规模。\n5. 氢能：氢能作为一种清洁、高效的能源载体，正处于研发和示范阶段。\n\n## 三、绿色能源发展挑战\n\n1. 投资成本：绿色能源项目初始投资较高，需要政策支持和金融创新降低成本。\n2. 技术瓶颈：部分绿色能源技术尚未成熟，需要加大研发力度，提高转换效率。\n3. 电网调峰：可再生能源的波动性和间歇性对电网调度提出更高要求。\n4. 政策法规：完善绿色能源政策体系，加强法规约束，促进产业发展。\n\n## 四、绿色能源未来发展趋势\n\n1. 技术创新：绿色能源技术不断突破，成本降低，应用领域拓展。\n2. 产业融合：绿色能源与互联网、大数据等产业深度融合，形成智慧能源新业态。\n3. 市场竞争：绿色能源市场竞争加剧，优质企业脱颖而出。\n4. 国际合作：加强绿色能源国际合作，共同应对全球气候变化。\n\n总之，绿色能源发展是实现可持续未来的关键途径。我国政府高度重视绿色能源发展，制定了一系列政策措施，推动产业转型升级。在全球范围内，绿色能源发展也呈现出良好的势头。然而，要实现绿色能源的全面发展，仍需各方共同努力，克服挑战，推动技术创新，完善政策体系，加强国际合作。只有这样，我们才能共同迈向一个清洁、低碳、绿色的美好未来。\n', NULL, NULL, '2024-05-08 14:51:51', '2024-05-08 14:51:51', 1);
INSERT INTO `articles` VALUES (61, '开发流程', '', NULL, '## 1.1 软件开发流程\n\n今天是星期二\n\n### 第 1 阶段: 需求分析\n\n完成产品原型、需求规格说明书的编写。\n\n产品原型，一般是通过网页(`html`)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。\n\n需求规格说明书， 一般来说就是使用 Word 文档来描述当前项目有哪些功能，每一项功能的需求及业务流程是什么样的，都会在文档中描述。\n\n### 第 2 阶段: 设计\n\n设计的内容包含 产品设计、UI界面设计、概要设计、详细设计、数据库设计。\n\n在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字段，字段类型都会在文档中描述清楚。\n\n### 第 3 阶段: 编码\n\n编写项目代码、并完成单元测试。\n\n作为软件开发工程师，我们主要的工作就是在该阶段， 对分配给我们的模块功能，进行编码实现。编码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。\n\n### 第 4 阶段: 测试\n\n在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。\n\n### 第 5 阶段: 上线运维\n\n在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发好的项目，部署在服务器上运行。\n\n我们作为软件开发工程师， 我们主要的任务是在编码阶段， 但是在一些小的项目组当中， 也会涉及到数据库的设计、测试等方面的工作。\n\n## 1.2 角色分工\n\n学习了软件开发的流程之后， 我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及各个角色的职责分工。\n\n\n| 岗位/角色  | 职责/分工                                  |\n| ---------- | ------------------------------------------ |\n| 项目经理   | 对整个项目负责，任务分配、把控进度         |\n| 产品经理   | 进行需求调研，输出需求调研文档、产品原型等 |\n| UI设计师   | 根据产品原型输出界面效果图                 |\n| 架构师     | 项目整体架构设计、技术选型等               |\n| 开发工程师 | 功能代码实现                               |\n| 测试工程师 | 编写测试用例，输出测试报告                 |\n| 运维工程师 | 软件环境搭建、项目上线                     |\n\n上述我们讲解的角色分工, 是在一个项目组中比较标准的角色分工, 但是在实际的项目中, 有一些项目组由于人员配置紧张, 可能并没有专门的架构师或测试人员, 这个时候可能需要有项目经理或者程序员兼任。\n\n## 1.3 软件环境\n\n在我们日常的软件开发中，会涉及到软件开发中的三套环境， 那么这三套环境分别是: 开发环境、测试环境、生产环境。 接下来，我们分别介绍一下这三套环境的作用和特点。\n\n### 开发环境(development)\n\n我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。\n\n比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地， 也可以安装在一台专门的服务器中， 这些应用软件仅仅在软件开发过程中使用， 项目测试、上线时，我们不会使用这套环境了，这个环境就是开发环境。\n\n### 测试环境(testing)\n\n当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境， 也就是测试环境，用于项目测试，一般外部用户无法访问。\n\n### 生产环境(production)\n\n当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对外提供服务，这个线上环境也称之为生产环境。\n\n> 拓展知识:\n>\n> 准生产环境：对于有的公司来说，项目功能开发好, 并测试通过以后，并不是直接就上生产环境。\n> 为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环境中, 测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的克隆体，准生产环境的服务器配置, 安装的应用软件(JDK、Tomcat、数据库、中间件 ...) 的版本都一样，这种环境也称为 \"仿真环境\"。\n>\n> ps.由于项目的性质和类型不同，有的项目可能不需要这个环境\n', NULL, NULL, '2024-05-08 15:16:37', '2024-05-08 15:16:37', 0);
INSERT INTO `articles` VALUES (62, '知识库介绍', '软件开发流程的概述', NULL, NULL, NULL, NULL, '2024-05-08 15:26:57', '2024-05-08 15:26:57', 1);
INSERT INTO `articles` VALUES (63, '软件开发流程', '', NULL, '## 1.1 软件开发流程\n\n今天是星期二\n\n### 第 1 阶段: 需求分析\n\n完成产品原型、需求规格说明书的编写。\n\n产品原型，一般是通过网页(`html`)的形式展示当前的页面展示什么样的数据, 页面的布局是什么样子的，点击某个菜单，打开什么页面，点击某个按钮，出现什么效果，都可以通过产品原型看到。\n\n需求规格说明书， 一般来说就是使用 Word 文档来描述当前项目有哪些功能，每一项功能的需求及业务流程是什么样的，都会在文档中描述。\n\n### 第 2 阶段: 设计\n\n设计的内容包含 产品设计、UI界面设计、概要设计、详细设计、数据库设计。\n\n在设计阶段，会出具相关的UI界面、及相关的设计文档。比如数据库设计，需要设计当前项目中涉及到哪些数据库，每一个数据库里面包含哪些表，这些表结构之间的关系是什么样的，表结构中包含哪些字段，字段类型都会在文档中描述清楚。\n\n### 第 3 阶段: 编码\n\n编写项目代码、并完成单元测试。\n\n作为软件开发工程师，我们主要的工作就是在该阶段， 对分配给我们的模块功能，进行编码实现。编码实现完毕后，进行单元测试，单元测试通过后再进入到下一阶段。\n\n### 第 4 阶段: 测试\n\n在该阶段中主要由测试人员, 对部署在测试环境的项目进行功能测试, 并出具测试报告。\n\n### 第 5 阶段: 上线运维\n\n在项目上线之前， 会由运维人员准备服务器上的软件环境安装、配置， 配置完毕后， 再将我们开发好的项目，部署在服务器上运行。\n\n我们作为软件开发工程师， 我们主要的任务是在编码阶段， 但是在一些小的项目组当中， 也会涉及到数据库的设计、测试等方面的工作。\n\n## 1.2 角色分工\n\n学习了软件开发的流程之后， 我们还有必要了解一下在整个软件开发过程中涉及到的岗位角色，以及各个角色的职责分工。\n\n\n| 岗位/角色  | 职责/分工                                  |\n| ---------- | ------------------------------------------ |\n| 项目经理   | 对整个项目负责，任务分配、把控进度         |\n| 产品经理   | 进行需求调研，输出需求调研文档、产品原型等 |\n| UI设计师   | 根据产品原型输出界面效果图                 |\n| 架构师     | 项目整体架构设计、技术选型等               |\n| 开发工程师 | 功能代码实现                               |\n| 测试工程师 | 编写测试用例，输出测试报告                 |\n| 运维工程师 | 软件环境搭建、项目上线                     |\n\n上述我们讲解的角色分工, 是在一个项目组中比较标准的角色分工, 但是在实际的项目中, 有一些项目组由于人员配置紧张, 可能并没有专门的架构师或测试人员, 这个时候可能需要有项目经理或者程序员兼任。\n\n## 1.3 软件环境\n\n在我们日常的软件开发中，会涉及到软件开发中的三套环境， 那么这三套环境分别是: 开发环境、测试环境、生产环境。 接下来，我们分别介绍一下这三套环境的作用和特点。\n\n### 开发环境(development)\n\n我们作为软件开发人员，在开发阶段使用的环境，就是开发环境，一般外部用户无法访问。\n\n比如，我们在开发中使用的MySQL数据库和其他的一些常用软件，我们可以安装在本地， 也可以安装在一台专门的服务器中， 这些应用软件仅仅在软件开发过程中使用， 项目测试、上线时，我们不会使用这套环境了，这个环境就是开发环境。\n\n### 测试环境(testing)\n\n当软件开发工程师，将项目的功能模块开发完毕，并且单元测试通过后，就需要将项目部署到测试服务器上，让测试人员对项目进行测试。那这台测试服务器就是专门给测试人员使用的环境， 也就是测试环境，用于项目测试，一般外部用户无法访问。\n\n### 生产环境(production)\n\n当项目开发完毕，并且由测试人员测试通过之后，就可以上线项目，将项目部署到线上环境，并正式对外提供服务，这个线上环境也称之为生产环境。\n\n> 拓展知识:\n>\n> 准生产环境：对于有的公司来说，项目功能开发好, 并测试通过以后，并不是直接就上生产环境。\n> 为了保证我们开发的项目在上线之后能够完全满足要求，就需要把项目部署在真实的环境中, 测试一下是否完全符合要求啊，这时候就诞生了准生产环境，你可以把他当做生产环境的克隆体，准生产环境的服务器配置, 安装的应用软件(JDK、Tomcat、数据库、中间件 ...) 的版本都一样，这种环境也称为 \"仿真环境\"。\n>\n> ps.由于项目的性质和类型不同，有的项目可能不需要这个环境\n', NULL, NULL, '2024-05-08 17:29:38', '2024-05-08 17:29:38', 1);

SET FOREIGN_KEY_CHECKS = 1;
