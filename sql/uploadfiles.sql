/*
 Navicat Premium Data Transfer

 Source Server         : blog_db
 Source Server Type    : MySQL
 Source Server Version : 80028
 Source Host           : localhost:3306
 Source Schema         : order

 Target Server Type    : MySQL
 Target Server Version : 80028
 File Encoding         : 65001

 Date: 10/05/2024 15:02:10
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for uploadfiles
-- ----------------------------
DROP TABLE IF EXISTS `uploadfiles`;
CREATE TABLE `uploadfiles`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `sid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '用于问题定位ID',
  `fileId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '上传的文件id',
  `summary` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '文件总结',
  `createdAt` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0),
  `updatedAt` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0),
  `articleId` int(0) NULL DEFAULT NULL COMMENT '所属文档id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 23 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of uploadfiles
-- ----------------------------
INSERT INTO `uploadfiles` VALUES (1, '696cd60352ab437a833e64f0ad64da8e', '497520aa07b944969b084d20dc689f9c', '信息系统开发常用的方法包括结构化方法、面向对象方法和原型化方法。结构化方法强调系统的生命周期阶段性和模块化设计，适用于数据处理领域问题，但开发周期长且难以适应需求变化。面向对象方法以对象作为基本元素，更符合人类的思维模式，有利于系统开发过程中的交流，缩短开发周期，但依赖特定的技术支持，不适用于大型项目。原型化方法通过快速构建系统模型与用户交流来明确需求，分为抛弃式和演化式两种，能缩短开发周期并提高用户满意度，但对开发环境和管理水平要求高，不适用于技术难度大的系统。各种方法各有优劣，实际开发中可根据项目特点灵活选择或结合使用。面向服务的方法（Service-Oriented, SO）是一种系统开发思想，它强调将功能模块化为独立的服务，通过定义清晰的接口来实现不同服务之间的通信和互操作。这种方法的核心在于解耦服务的接口定义与具体实现，从而增强系统的复用性、灵活性和互操作性。随着组织内部及组织间的应用系统日益复杂，SO方法使得信息系统能够快速适应需求变化和环境变动，有效提升了信息化建设的效率。尽管面向服务的方法是一个相对较新的领域，且许多实践仍需探索，但它已经被视为信息系统建设的重要趋势，并被越来越多的组织采纳实施。', '2024-04-28 14:02:44', '2024-04-28 14:02:44', 47);
INSERT INTO `uploadfiles` VALUES (2, '45f3d79400674b76965e15e37db7ab91', 'a6335a512cb94c5da6fa4d466dc3dff4', '软件开发流程通常分为五个主要阶段：需求分析、设计、编码、测试和上线运维。在需求分析阶段，开发团队会创建产品原型和需求规格说明书，以明确软件的功能和布局。设计阶段涉及产品设计、UI界面设计、概要设计、详细设计和数据库设计，确保所有功能和数据结构得到妥善规划。编码阶段是程序员根据设计文档编写代码并进行单元测试的环节。测试阶段由测试人员在测试环境中对软件进行全面测试，并生成测试报告。最后，上线运维阶段包括服务器环境的准备和软件的部署工作。\\n\' +\r\n      \'\\n\' +\r\n      \'在整个软件开发过程中，不同的角色承担不同的职责。项目经理负责整体项目进度和任务分配，产品经理进行需求调研并输出相关文档，UI设计师负责界 面效果，架构师处理技术选型和架构设计，开发工程师实现功能代码，测试工程师编写测试用例并输出测试报告，运维工程师负责软件环境的搭建和项目上线。在一些小型项目组中，某些角色可能需要由其他职位兼任。\\n\' +\r\n      \'\\n\' +\r\n      \'软件开发还涉及到三套主要环境：开发环境、测试环境和生产环境。开发环境是开发人员使用的，用于代码开发和初步测试；测试环境供测试人员使用， 用于全面测试软件功能；生产环境是软件正式上线并提供外部服务的环境。此外，有些公司还会使用准生产环境，它是生产环境的克隆体，用于在真实环境中测试软件，以确保上线后能够满足所有要求。\'', '2024-05-08 15:07:09', '2024-05-08 15:07:09', 45);
INSERT INTO `uploadfiles` VALUES (3, '0afd7306590549799141ed41dbab05db', '630d12e983e94c69953469e7a17ba945', 'ER图（实体关系图）是一种用于描述数据库中不同实体之间关系的图形化工具。它通过直观的方式展示了数据模型、实体之间的联系以及数据流动，帮助设计人员和其他相关人员更好地理解和沟通数据库的设计意图。\n\n在ER图中，实体用矩形表示，属性用椭圆或矩形中的文本表示，关系用菱形表示，线条表示实体之间的连接和关系。实体是现实世界中独立存在并具有独特属性的事物或对象，可以是物理对象或抽象概念。每个实体通常具有一些属性，用于描述实体的特征。\n\n实体间的关系包括一对一（One-to-One）、一对多（One-to-Many）和多对多（Many-to-Many）。一对一关系表示一个实体在一个表中与另一个实体在另一个表中存在唯一对应关系。一对多关系表示一个实体在一个表中可以与多个实体在另一个表中关联。多对多关系表示多个实体在一个表中可以与多个实体在另一个表中关联，需要使用中间表来建立连接。\n\n总结来说，ER图是一种用于描述数据库中实体及其关系的图形化工具。它通过直观的方式展示了实体、属性和关系之间的结构，帮助设计人员和其他相关人员更好地理解和沟通数据库的设计意图。实体是现实世界中独立存在并具有独特属性的事物或对象，可以是物理对象或抽象概念。实体间的关系包括一对一、一对多和多对多，用于描述不同实体之间的连接和关系。', '2024-04-28 16:06:04', '2024-04-28 16:06:04', 48);
INSERT INTO `uploadfiles` VALUES (4, '7b1084a90af74026b8dac9e9a7407394', 'db69833009254bd8a430418435e899ee', '以下是对以上内容的详细摘要：\n\nVue3的设计目标主要针对解决复杂组件维护困难、缺少在多个组件间提取和复用逻辑的机制、类型推断不友好以及打包时间过长等问题。为了解决这些问题，Vue3经过长时间的筹备，带来了许多改进和新特性，使得框架变得更小、更快且对TypeScript有更好的支持。\n\n具体来说，Vue3通过移除不常用的API和引入tree-shaking技术减小了体积。性能方面，Vue3优化了diff算法、实现了静态提升、引入了事件监听缓存以及对SSR进行了优化。这些性能上的改进显著提高了编译效率。\n\n在提高可维护性和开放底层功能方面，Vue3采用了monorepo方式管理源码，并使用TypeScript进行编写，提供了更好的类型检查和复杂的类型推导支持。同时，Vue3还引入了许多新特性，如Composition API、ref、reactive、computed、teleport等，这些新特性极大地丰富了Vue的功能性。\n\n其中，Composition API是Vue3中一个非常重要的新特性，它允许开发者将响应式数据和相关的业务逻辑组合在一起，便于维护，尤其在处理庞大组件时显得尤为重要。与Vue2的Options API相比，Composition API提供了更加灵活的逻辑组织和代码复用能力。\n\n总的来说，Vue3在设计上致力于解决实际开发中的痛点，通过一系列优化和新特性的引入，使得开发者可以更高效、更便捷地构建应用程序。', '2024-04-28 16:14:10', '2024-04-28 16:14:10', 49);
INSERT INTO `uploadfiles` VALUES (5, '154c3527ca1b4d83a8a367d1a7ef4c45', 'a2b686ee25cf419dab74b00e24640389', '在JavaScript中，实现对象属性的响应式更新有两种方式：`Object.defineProperty`和`Proxy`。\n\n`Object.defineProperty`方法可以直接在一个对象上定义一个新属性或修改一个对象的现有属性。它主要通过两个特性来实现响应式：`get`和`set`。`get`是属性的getter函数，当访问该属性时会调用此函数；`set`是属性的setter函数，当属性值被修改时会调用此函数。然而，`Object.defineProperty`有一些局限性，例如无法检测到对象属性的添加和删除，数组的某些方法（如`push`, `pop`）无法监听到，如果存在深层的嵌套对象关系，需要深层监听，这会造成性能问题。\n\n相比之下，`Proxy`可以针对一个对象的所有操作进行监听，这就完全可以代理所有属性了。`Proxy`可以直接劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的。`Proxy`可以直接监听数组的变化（`push`、`shift`、`splice`），并且有多达13种拦截方法，如`apply`、`ownKeys`、`deleteProperty`、`has`等，这是`Object.defineProperty`不具备的。但是，`Proxy`不兼容IE，也没有`polyfill`，而`Object.defineProperty`能支持到IE9。\n\n总的来说，`Object.defineProperty`和`Proxy`都可以实现响应式，但`Proxy`的功能更强大，使用更简单，而`Object.defineProperty`兼容性更好。', '2024-05-05 19:12:58', '2024-05-05 19:12:58', 50);
INSERT INTO `uploadfiles` VALUES (6, '3a64b824085d4b4680da1b883493a236', 'a010ca2a83bc41d99ea7d6437c9fd627', '以上内容主要介绍了函数柯里化、手写 `new`、手写 `call`、手写 `apply`、手写 `bind`、实现 `AJAX` 请求以及迭代器的相关知识。\n\n函数柯里化是一种将多个参数的函数转换为接收单个参数的函数链式调用的技术。它可以用于函数复用和延迟执行。手写 `new` 需要构造函数作为参数第一项，构造函数的 `prototype` 原型对象指向实例对象，并更改构造函数执行时的 `this` 指向，并获取执行结果。手写 `call` 和 `apply` 需要传递参数列表，立即执行函数，只是临时改变 `this` 指向一次。手写 `bind` 与 `call` 一样传递参数列表，但不会立刻执行函数，而是返回一个永久改变 `this` 指向的函数。\n\n实现 `AJAX` 请求可以通过 `XMLHTTPRequest` 对象来实现。它返回一个 `Promise` 对象，用于处理异步操作。迭代器是返回 `next()` 方法的对象，用于控制每次调用时返回的值。对于没有迭代器的对象，可以通过添加 `Symbol.iterator` 属性来实现迭代。生成器可以使用 `yield` 语句来控制每次调用时返回的值，并在生成一个值后暂停函数的执行状态，以便在下一次请求值时继续执行。\n\n总之，以上内容详细介绍了函数柯里化、手写 `new`、手写 `call`、手写 `apply`、手写 `bind`、实现 `AJAX` 请求以及迭代器的相关知识。这些技术在 JavaScript 编程中非常重要，可以帮助我们更好地处理函数调用、对象实例化、异步操作和迭代等场景。', '2024-05-05 13:39:01', '2024-05-05 13:39:01', 53);
INSERT INTO `uploadfiles` VALUES (8, '1989f051b94b4718bf96adeeac7c5ddd', 'a0e068c5b21a41859e2988c96d5bd9a0', '在计算机编程中，有许多常见的概念和技术需要掌握。本文将重点介绍数组扁平化、拷贝、防抖节流、布局和省略号等核心要点。\n\n1. 数组扁平化：数组扁平化是将多维数组转换为一维数组的过程。可以使用递归或`reduce()`方法实现。例如，使用递归的方法：\n```javascript\nfunction alip(arr) {\n  let newArr = [];\n  for (let item of arr) {\n    if (Array.isArray(item)) {\n      alip(item);\n    } else {\n      newArr.push(item);\n    }\n  }\n  return newArr;\n}\n```\n\n2. 拷贝：拷贝是将对象或数组的值复制到另一个变量中的过程。分为浅拷贝和深拷贝。浅拷贝只复制基本数据类型的值，而深拷贝会递归地复制引用数据类型的值。例如，使用递归的方法实现深拷贝：\n```javascript\nfunction deepCopy(target) {\n  if (typeof target === \"object\") {\n    const newTarget = Array.isArray(target) ? [] : {};\n    for (const key in target) {\n      newTarget[key] = deepCopy(target[key]);\n    }\n    return newTarget;\n  } else {\n    return target;\n  }\n}\n```\n\n3. 防抖节流：防抖和节流是优化高频触发事件的技术。防抖是指在事件触发后延迟一段时间再执行函数，而节流是指在一定时间内只执行一次函数。例如，使用防抖的方法：\n```javascript\nfunction debounce(fn, delay) {\n  let timer = null;\n  return function (...args) {\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(this, args);\n      timer = null;\n    }, delay || 1000 / 60);\n  };\n}\n```\n\n4. 布局：布局是指网页元素的排列方式。常见的布局有两栏布局和三栏布局。两栏布局一般是左侧固定，右侧自适应；三栏布局一般是左右两侧固定，中间自适应。可以使用浮动、flex、绝对定位等技术实现。\n\n5. 省略号：省略号是用来表示文本内容被截断的符号。可以使用伪元素、旧版弹性盒子或单行文字省略等方法实现。\n\n综上所述，本文介绍了数组扁平化、拷贝、防抖节流、布局和省略号等核心要点。掌握这些知识点可以帮助我们更好地编写高效的代码。', '2024-05-05 19:08:54', '2024-05-05 19:08:54', 51);
INSERT INTO `uploadfiles` VALUES (9, '3dfaeef9ec1542c39026f8d5a46e4a02', '656a602be9cc46d59a9ba2a92a5590e0', 'ES6引入了扩展运算符`...`，它类似于rest参数的逆运算。通过扩展运算符，可以将一个数组转为用逗号分隔的参数序列。扩展运算符的应用主要包括函数调用、数据结构转换、数组复制、数组合并以及与解构赋值结合生成数组等。需要注意的是，通过扩展运算符实现的是浅拷贝，修改引用指向的值会同步反映到新数组中。\n\n此外，ES6还为数组新增了一些构造函数方法，包括Array.from()和Array.of()。Array.from()可以将类似数组的对象和可遍历的对象（如Set和Map）转换为真正的数组。它还可以接受第二个参数，用于对每个元素进行处理，将处理后的值放入返回的数组中。Array.of()用于将一组值转换为数组。当参数只有一个时，实际上是指定数组的长度；参数个数不少于2个时，Array()才会返回由参数组成的新数组。\n\n综上所述，ES6中的扩展运算符和新增的数组构造函数方法为JavaScript提供了更加灵活和便捷的数组操作方式。', '2024-05-05 19:22:38', '2024-05-05 19:22:38', 52);
INSERT INTO `uploadfiles` VALUES (10, '7bae16c7812940bb8c8d850dc513f36e', '43be41b5ef964d2cb78c602ba9f18941', '白屏时间是指从用户输入URL到页面首次显示的时间，这是衡量网页加载速度的重要指标。白屏时间的长短直接影响用户体验，短的白屏时间可以提升用户对网页速度的感知，从而提高用户体验，减少用户跳出率，提升页面留存率。\n\n白屏过程包括以下几个步骤：首先，浏览器会检查缓存，如果缓存中有相关数据，会直接显示页面内容；其次，浏览器需要进行域名解析DNS，获取对应的IP地址；然后，浏览器与服务器建立TCP连接，进行三次握手；握手成功后，浏览器向服务器发送HTTP请求，请求数据包；服务器接收请求，处理后将数据返回给浏览器；浏览器收到HTTP响应后，读取页面内容，进行渲染，解析HTML，生成DOM树，解析CSS样式，执行JS交互，最后渲染显示页面。\n\n在这个过程中，JavaScript会阻塞DOM的生成，而样式文件又会阻塞JavaScript的执行。因此，优化白屏时间的方法包括：优化DNS缓存，使用稳定的DNS服务器，优化TCP网络链路，优化服务器处理，以及优化浏览器下载、解析、渲染页面的过程。例如，不使用内联的JS，或者配合defer async使用，异步加载JS；关键CSS代码可以内联到HTML中，这样可以在结束HTML下载后马上渲染，缩短首屏渲染时间；延迟首屏不需要的图片的加载等。', '2024-05-07 16:48:56', '2024-05-07 16:48:56', 54);
INSERT INTO `uploadfiles` VALUES (11, 'f8cf733a06dc494d82f60e0579f378a2', 'd8006a5f8ea14e78b3ed4199f3e6767a', 'Web Worker是HTML5规范的一部分，它允许在JS主线程之外开辟新的Worker线程。这样做的目的是解决JS单线程中大量运算任务导致的阻塞问题，从而提高页面的流畅度和用户体验。Worker线程与JS主线程相对独立，它们之间通过postMessage方法进行消息传递，监听message事件来接收消息。值得注意的是，Worker线程无法访问与主线程有关的变量以及DOM元素，因为它们运行在沙箱环境中。\n\n创建Worker线程的方法是使用new Worker(path, options)，其中path是有效的脚本地址。主线程可以主动关闭与Worker线程的连接，而Worker线程也可以执行self.close()方法来关闭自身。此外，Worker线程可以通过importScripts方法引用其他JS文件，且不受同源策略约束。\n\n总的来说，Web Worker的引入主要是为了改善前端应用的响应性，使其能够更好地处理计算密集型任务，而不是将JavaScript彻底转变为多线程编程语言。JavaScript的主要应用领域仍然是处理用户界面和用户交互。', '2024-05-07 17:13:41', '2024-05-07 17:13:41', 55);
INSERT INTO `uploadfiles` VALUES (13, '3703394bf64f4aaab5c2ec68472b3189', 'bc096490359d4a04943db435f0f8df66', 'setTimeout和setInterval是JavaScript中常用的定时器函数，它们都用于在指定的时间后执行某个函数或代码。它们的运行机制有一些不同之处。\n\n首先，setTimeout允许我们指定一个函数或代码在多少毫秒之后执行。它返回一个整数代表定时器的编号，可以通过clearTimeout来清除定时器。无论setTimeout的执行时间是0还是更多，都是在同步函数之后执行。例如：\n```javascript\nconsole.log(1);\nsetTimeout(function () {\n    console.log(2);\n}, 0);\nconsole.log(3);\n// 输出结果为：1 3 2\n```\n在这个例子中，尽管setTimeout的延迟时间为0，但它仍然会在同步代码执行完毕后才会被调用。\n\n而setInterval也是异步任务，它会每隔指定的时间将回调函数加入到任务队列中等待执行。但是，如果前面的任务没有完成，定时器会将回调再次放入任务队列中，导致某些间隔会被跳过，并且可能多个定时器会连续执行。\n\n因此，在使用setInterval时需要注意，如果任务执行时间较长，可能会导致定时器执行不准确。为了避免这种情况，可以考虑使用setTimeout结合递归来实现周期性执行的任务。\n\n总之，setTimeout和setInterval都是JavaScript中常用的定时器函数，它们可以用于在指定的时间后执行某个函数或代码。setTimeout是异步任务，通过指定延迟时间来控制函数的执行时机；而setInterval也是异步任务，通过设置间隔时间来周期性地执行回调函数。但在使用时需要注意它们的特点和潜在的问题。', '2024-05-07 17:17:40', '2024-05-07 17:17:40', 56);
INSERT INTO `uploadfiles` VALUES (17, '0e5d9a0bdbb04b2b98fc1bb8f867a7c5', 'c106469fffbd4b73a810f6f4f1b58a7a', '在 Vue.js 中，v-model 指令主要用于表单元素上，实现双向数据绑定。然而，对于自定义组件，v-model 的使用需要借助于 model 选项和自定义事件。\n\n首先，子组件需要定义 model 选项，其中 prop 属性用于指定接收值的 prop 名称，event 属性用于指定当值发生变化时触发的自定义事件名称。同时，子组件需要定义一个与 prop 同名的 data 属性，用于存储接收到的值。\n\n其次，子组件需要在 methods 中定义一个方法，该方法在值发生变化时被调用，用于触发自定义事件，并将新值作为参数传递给父组件。\n\n最后，父组件在使用子组件时，通过 v-model 指令将子组件的 value prop 和 change event 绑定在一起。这样，当子组件触发 change 事件时，v-model 绑定的变量会自动更新。\n\n总的来说，通过 model 选项和自定义事件，我们可以在自定义组件中实现 v-model 的功能，从而实现父子组件之间的双向数据绑定。', '2024-05-07 17:48:39', '2024-05-07 17:48:39', 57);
INSERT INTO `uploadfiles` VALUES (18, 'ac0c61830e004274b9cc04dced8c6475', 'd5925c019f7c4ee398b0cdc5016c2ffb', 'TypeScript是一种面向对象的编程语言，它的核心概念包括类、继承、接口和泛型。在TypeScript中，一切皆是对象，对象是程序对事物的抽象，包含数据和功能两部分。类是对象的抽象，对象是类的实例。通过定义类可以创建不同的对象。继承是面向对象的重要特性之一，子类可以继承父类的属性和方法，也可以重写父类的方法。接口定义了一个规范，实现接口需要使用`implements`关键字。泛型是一种类型参数化的方式，可以在定义类、接口或函数时不预先指定具体的类型，而是在使用时再指定类型。封装是一种重要的思想，通过将属性设置为私有，并提供公有的getter和setter方法来访问和修改属性，可以保护对象内部的数据不被外部随意修改。总之，TypeScript中的接口实现和泛型提供了强大的类型检查和灵活性，使得代码更加健壮和易于维护。', '2024-05-07 18:30:49', '2024-05-07 18:30:49', 58);
INSERT INTO `uploadfiles` VALUES (19, '02621bb76e394beebf76f035a69dcca1', '30812d6fa17a406b94ba3e314b3ab8ae', '在JavaScript中，实现对象属性的响应式更新可以通过`Object.defineProperty()`和`Proxy`两种机制。`Object.defineProperty()`通过直接在一个对象上定义新属性或修改现有属性，并返回此对象。它利用了getter和setter函数，当访问或修改属性时触发这些函数，从而可以实现对数据变化的监听和处理。然而，这种方法只能针对已存在的属性进行监听，对于新增或删除的属性无法感知，同时对于数组的索引变化也无法监听到。此外，如果存在深层嵌套的对象结构，会导致性能问题，因为需要递归地对每个属性进行监听。\n\n相比之下，`Proxy`提供了一种更全面的对象监听机制。它允许开发者在对象操作（如读取、写入、删除等）时进行拦截，并可以对整个对象进行监听，而不仅仅是属性。这意味着使用`Proxy`可以更容易地实现对对象的全面监控，包括数组的变化和其他复杂的操作。`Proxy`有多达13种拦截方法，提供了更多的操作选项，这是`Object.defineProperty()`所不具备的。\n\n尽管`Proxy`在功能上更加强大，但它不兼容IE浏览器，并且没有可用的polyfill。而`Object.defineProperty()`虽然功能有限，但兼容性更好，能够支持到IE9。\n\n总结来说，`Object.defineProperty()`和`Proxy`都可以实现对象属性的响应式更新，但各有优劣。`Object.defineProperty()`适用于简单的属性监听和旧版浏览器兼容性要求较高的场景，而`Proxy`则适用于需要全面监控对象操作的现代浏览器环境。', '2024-05-08 13:47:44', '2024-05-08 13:47:44', 59);
INSERT INTO `uploadfiles` VALUES (20, '15040f4c8c6f46a6adfa66f12d84714e', '31a7480b774b420f990f112acfadff92', '绿色能源，即可再生能源，对环境友好且不会耗尽，包括太阳能、风能、水能和生物质能等。它在环境保护、能源安全、经济效益和社会责任方面具有重要性。目前，绿色能源发展呈现积极态势：太阳能和风能技术成熟并应用广泛，水力发电经济效益高，生物质能产业初具规模，氢能处于研发阶段。然而，其发展面临投资成本高、技术瓶颈、电网调峰和政策法规完善的挑战。未来发展趋势显示技术创新将推动成本降低，产业融合形成智慧能源新业态，市场竞争将促进优质企业发展，国际合作助力共同应对气候变化。中国及全球均在积极推动绿色能源发展，但实现全面发展仍需共同努力，克服挑战，推动技术创新，完善政策体系，加强国际合作，以迈向清洁、低碳、绿色的美好未来。', '2024-05-08 14:52:53', '2024-05-08 14:52:53', 60);
INSERT INTO `uploadfiles` VALUES (21, '297ba621a22d4872920dc444d904ca34', '737b13ff6e2046df93c674acdd0a479a', '本文主要介绍了软件开发的整个流程，包括需求分析、设计、编码、测试和上线运维等五个阶段。在需求分析阶段，需要完成产品原型和需求规格说明书的编写；设计阶段则包括产品设计、UI界面设计、概要设计、详细设计和数据库设计等内容；编码阶段主要是编写项目代码并完成单元测试；测试阶段由测试人员对部署在测试环境的项目进行功能测试，并出具测试报告；上线运维阶段则是准备服务器上的软件环境安装、配置，并将开发好的项目部署在服务器上运行。\n\n在整个软件开发过程中涉及到的岗位角色有项目经理、产品经理、UI设计师、架构师、开发工程师、测试工程师和运维工程师等。其中，项目经理负责整个项目的把控和管理；产品经理进行需求调研并输出相关文档和产品原型；UI设计师根据产品原型输出界面效果图；架构师负责项目整体架构设计和技术选型；开发工程师实现功能代码；测试工程师编写测试用例并输出测试报告；运维工程师负责软件环境搭建和项目上线。\n\n此外，文章还介绍了软件开发中的三套环境：开发环境、测试环境和生产环境。开发环境是开发人员在开发阶段使用的环境；测试环境是给测试人员使用的环境，用于项目测试；生产环境则是项目上线后对外提供服务的线上环境。', '2024-05-08 15:15:51', '2024-05-08 15:15:51', 61);
INSERT INTO `uploadfiles` VALUES (22, 'b9a9609fcf89498bb1512c1ef21a47c4', '41769795cced414bad713bdf1dbc3dcf', '本文主要介绍了软件开发的标准流程，包括需求分析、设计、编码、测试和上线运维五个阶段。在需求分析阶段，需要完成产品原型和需求规格说明书的编写；设计阶段则包括产品设计、UI界面设计、概要设计、详细设计和数据库设计；编码阶段主要是编写项目代码并完成单元测试；测试阶段由测试人员对项目进行功能测试并出具测试报告；最后的上线运维阶段则是准备服务器环境并将项目部署运行。\n\n在整个软件开发过程中，涉及到的角色有项目经理、产品经理、UI设计师、架构师、开发工程师、测试工程师和运维工程师，他们各自负责不同的任务和职责。然而，在实际项目中，由于人员配置紧张，有些角色可能需要由其他人员兼任。\n\n此外，软件开发中还涉及到三套环境：开发环境、测试环境和生产环境。开发环境是开发人员在开发阶段使用的环境；测试环境是供测试人员进行项目测试的环境；生产环境则是项目上线后对外提供服务的环境。有些公司还会设置准生产环境，用于在真实环境中测试项目是否符合要求。', '2024-05-08 17:29:44', '2024-05-08 17:29:44', 63);

SET FOREIGN_KEY_CHECKS = 1;
